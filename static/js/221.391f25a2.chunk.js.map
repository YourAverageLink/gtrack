{"version":3,"file":"static/js/221.391f25a2.chunk.js","mappings":"6HAAMA,EAAMC,OAAO,GACbC,EAAOD,OAAO,GAoBb,IAAME,EAAS,WAOlB,WAAYC,EAAeC,IAAuB,oBANlDC,UAAI,OACJD,YAAM,EAMFE,KAAKD,KAAW,OAAJF,QAAI,IAAJA,EAAAA,EAAQF,EACpBK,KAAKF,OAAe,OAANA,QAAM,IAANA,EAAAA,EAAU,IAAIG,GAChC,CAsFC,OApF+D,8BAChE,SAAOC,GAGH,OAFAF,KAAKD,MAAQN,GAAOC,OAAOQ,GAC3BF,KAAKF,OAAOK,IAAID,GACTF,IACX,GAEA,sBACA,SAASE,GAKL,OAJIF,KAAKF,OAAOM,IAAIF,KAChBF,KAAKD,KAAOC,KAAKD,MAAQN,GAAOC,OAAOQ,IACvCF,KAAKF,OAAOO,OAAOH,IAEhBF,IACX,GAEA,iBACA,SAAIM,GACA,OAAO,IAAIV,EAAUU,EAAMP,KAAOC,KAAKD,KAhD/C,SAAyBQ,EAAWC,GAChC,GAAID,EAAEE,KAAOD,EAAEC,KAAM,CACjB,IAAMC,EAAMH,EAEZA,EAAIC,EAEJA,EAAIE,CACR,CACA,OAAO,IAAIT,KAAI,OAAIM,GAAGI,QAAO,SAACC,GAAC,OAAKJ,EAAEJ,IAAIQ,EAAE,IAChD,CAuCqDC,CAAaP,EAAMR,OAAQE,KAAKF,QACjF,GAEA,gBACA,SAAGQ,GACC,OAAO,IAAIV,EAAUU,EAAMP,KAAOC,KAAKD,MA1C7BQ,EA0CyCD,EAAMR,OA1CpCU,EA0C4CR,KAAKF,OAzCnE,IAAIG,IAAI,GAAD,eAAKM,IAAC,OAAKC,OAD7B,IAAkBD,EAAWC,CA2CzB,GAEA,kBACA,SAAKN,GACD,OAAOF,KAAKF,OAAOM,IAAIF,EAC3B,GAEA,wBACA,SAAWI,GACP,OAAON,KAAKc,YAAcR,EAAMQ,aAAed,KAAKD,KAAOO,EAAMP,QAAUO,EAAMP,IACrF,GAEA,oBACA,SAAOO,GACH,OAAON,KAAKD,OAASO,EAAMP,IAC/B,GAEA,sBAGA,SAASgB,GAEL,IADA,IAAIC,EAAM,GACDd,EAAMa,EAAa,EAAGb,GAAO,EAAGA,IACjCF,KAAKD,KAAQN,GAAOC,OAAOQ,GAC3Bc,GAAO,IAEPA,GAAO,IAGf,OAAOA,CACX,GAEA,mBACA,WACI,OAAO,IAAIpB,EAAUI,KAAKD,KAAM,IAAIE,IAAID,KAAKF,QACjD,GAEA,qBACA,WACI,OAA2B,IAApBE,KAAKc,UAChB,GAEA,wBACA,SAAWR,GACP,OAAOW,QAAQjB,KAAKD,KAAOO,EAAMP,KACrC,GAEA,kBACA,WACI,OAAOC,KAAKF,OAAOoB,QACvB,GAEA,6BACA,WACI,OAAOlB,KAAKF,OAAOoB,SAASC,OAAOC,KACvC,GAEA,sBACA,WACI,OAAOpB,KAAKF,OAAOW,IACvB,KAAC,EAhGiB,GChBTY,EAAiB,WAc1B,WAAYC,IAAqB,oBAbjCC,kBAAY,EAcRvB,KAAKuB,aAAeD,CACxB,CALC,OAOD,0BAIA,SAAGhB,GACC,OACW,IAAIe,EAAkB,GAAD,eAAKrB,KAAKuB,cADtCjB,aAAiBV,EACiC,CAAEU,IAG5B,OACjBA,EAAMiB,eAGrB,GAEA,iBAIA,SAAIjB,GACA,OAAIA,aAAiBV,EACV,IAAIyB,EACPG,EAAUxB,KAAKuB,aAAc,CAACjB,KAIlCN,KAAKyB,oBAAsBnB,EAAMmB,mBAC1BJ,EAAkBK,QAEtB,IAAIL,EACPG,EAAUxB,KAAKuB,aAAcjB,EAAMiB,cAE3C,GAEA,yBAIA,SAAYI,EAAcC,GACtB,OAAO,IAAIP,EACPrB,KAAKuB,aAAaM,KAAI,SAACC,GAAC,OACpBA,EAAEC,KAAKH,GAAUE,EAAIA,EAAEE,QAAQC,SAASN,EAAK,IAGzD,GAEA,8BAGA,WAEI,IAFgB,IAAD,OACTO,EAAqB,GAAG,aAE1B,IAAMC,EAAY,EAAKZ,aAAaa,GAEpC,IAAoB,IADDF,EAAMG,WAAU,SAACC,GAAC,OAAKA,EAAEC,WAAWJ,EAAU,IACzC,MAAD,WAIvB,IAAMK,EAAeN,EAAMG,WAAU,SAACC,GAAC,OACnCH,EAAUI,WAAWD,EAAE,KAEL,IAAlBE,EACAN,EAAMM,GAAgBL,EAEtBD,EAAMO,KAAKN,EAEnB,EAfSC,EAAI,EAAGA,EAAIpC,KAAKuB,aAAamB,OAAQN,IAAG,IAgBjD,OAAO,IAAIf,EAAkBa,EACjC,GAEA,kBAGA,SAAKS,GACD,OAAO3C,KAAKuB,aAAaqB,MAAK,SAACd,GAAC,OAAKA,EAAES,WAAWI,EAAI,GAC1D,GAEA,8BAGA,WACI,OAAoC,IAA7B3C,KAAKuB,aAAamB,MAC7B,GAEA,6BAGA,WACI,OACI1C,KAAKuB,aAAamB,OAAS,GAC3B1C,KAAKuB,aAAaqB,MAAK,SAACd,GAAC,OAAKA,EAAEe,SAAS,GAEjD,IAAC,oBA1GD,WACI,OAAO,IAAIxB,EAAkB,GACjC,GAEA,kBACA,WACI,OAAO,IAAIA,EAAkB,CAAC,IAAIzB,GACtC,KAAC,EAXyB,GAoH9B,SAAS4B,EAAUsB,EAAmBC,GAClC,IACoB,EADdC,EAAU,GAAG,UACHF,GAAI,IAApB,2BAAsB,CAAC,IACE,EADdG,EAAC,kBACQF,GAAK,IAArB,2BAAuB,CAAC,IAAbG,EAAC,QACRF,EAAQP,KAAKQ,EAAEE,GAAGD,GACtB,CAAC,+BACL,CAAC,+BACD,OAAOF,CACX,CCzCO,SAASI,EAEZC,EAEAC,EAEAC,EAMAC,GAEsB,IADtBC,EAA+B,uDAAG,IAAIxD,IAEtC,IAAIwD,EAAmBrD,IAAImD,GAA3B,CAGA,IAAMG,EAAOJ,EAAaC,GAC1B,IAAIG,EAAKjC,qBAIL+B,EAAmBpD,IAAImD,GAA3B,CAIAE,EAAmBtD,IAAIoD,GAAK,IAEqB,EAFrB,UAETD,EAAaC,GAAKhC,cAAY,IAAjD,2BAAmD,CAAC,IACnB,EADtBoC,EAAI,kBACOA,EAAKC,QAAM,IAA7B,2BAA+B,CAAC,IAArB1D,EAAG,QACV,IAAKmD,EAAWtB,KAAK7B,KAASsD,EAAmBpD,IAAIF,GAAM,CACvD,IAAM2D,EAAWT,EACbC,EACAC,EACApD,EACAsD,EACAC,GAEJ,GAAII,EACA,OAAO,IAAIjE,GACNkE,OAAO5D,GACPiD,GAAGU,EAEhB,CACJ,CAAC,+BACL,CAAC,+BAGD,OADAJ,EAAmBpD,OAAOkD,GACnB,IAAI3D,CAxBX,CARA,CAiCJ,CAQO,SAASmE,EACZV,EACAC,EACAC,GAEkB,IADlBE,EAA+B,uDAAG,IAAIxD,IAElC+D,EAAS3C,EAAAA,QACb,GAAIoC,EAAmBrD,IAAImD,GACvB,OAAOS,EAEXP,EAAmBtD,IAAIoD,GAkBvB,IAE2D,EAF3D,UAE6BD,EAAaC,GAAKhC,cAAY,IAA3D0C,EAAU,2BAAmD,CAAC,IAG7B,EAHZN,EAAI,QACjBO,EAAU7C,EAAAA,OACR8C,EAAiBd,EAAWe,IAAIT,GAAM,UAC1BA,EAAKC,QAAM,IAA7B,2BAA+B,CAAC,IAArB1D,EAAG,QACV,IAAKiE,EAAepC,KAAK7B,GAAM,CAC3B,IAAMmE,EAAUN,EACZV,EACAC,EACApD,EACAuD,GAEJ,GAAIY,EAAQ5C,mBACR,SAASwC,EAEbC,EAAUA,EAAQE,IAAIC,GAASC,kBACnC,CACJ,CAAC,+BACGH,EAAerD,aACfoD,EAAUA,EAAQE,IAAID,IAG1BH,EAASA,EAAOb,GAAGe,EACvB,CAAC,+BAGD,OADAT,EAAmBpD,OAAOkD,GACnBS,EAAOM,kBAClB,CAEO,SAASA,EAAiBC,GAAkB,IACN,EADK,UACpBA,EAAMC,WAAS,IAAzC,2BAA2C,CAAC,IAAD,qBAA/BjB,EAAG,KAAEG,EAAI,KACbA,EAAKnC,aAAamB,QAAU,IAC5B6B,EAAMhB,GAAOG,EAAKY,mBAE1B,CAAC,+BACL,CAUO,SAASG,EACZpB,EACAC,GAGA,IACgD,EAD1CoB,EAAoCpB,EAAazB,KAAI,iBAAM,EAAE,IAAE,UAC3CyB,EAAakB,WAAS,IAAhD,2BAAkD,CAAC,IAAD,qBAAtCjB,EAAG,KAAEG,EAAI,KACjB,IAAIL,EAAWtB,KAAKwB,GAApB,CAEC,IACmC,EADnC,UACkBG,EAAKnC,cAAY,IAApC,2BAAsC,CAAC,IAA5BoC,EAAI,QACX,GAAwB,IAApBA,EAAK7C,WAAkB,CACvB,IAAMZ,EAAMyD,EAAKgB,kBACjB,GAAIzE,IAAQqD,GAAOF,EAAWtB,KAAK7B,GAC/B,SAEHwE,EAAsBxE,GAAMuC,KAAKc,EACtC,CACJ,CAAC,+BATD,CAUJ,CAAC,+BAGD,IADA,IAAIqB,GAAa,EACRrE,EAAI,EAAGA,EAAI+C,EAAaZ,OAAQnC,IAAK,CAC1C,IAC0B,EADpBsE,EAAaH,EAAsBnE,GAAG,UAC5BsE,GAAU,IAA1B,2BAA4B,CACpBC,EAAmBxB,EAAc/C,EAD7B,WAEJqE,GAAa,EAErB,CAAC,+BACL,CAEA,OAAOA,CACX,CAcA,SAASE,EAAmBxB,EAAmC/C,EAAWC,GACtE,IAAMuE,EAAQzB,EAAa/C,GACrByE,EAAQ1B,EAAa9C,GAE3B,GAAIuE,EAAMxD,aAAamB,OAAS,GAAKsC,EAAMzD,aAAamB,OAAS,EAC7D,OAAO,EAGX,IAAMuC,EAAiBF,EAAMxD,aAAac,WACtC,SAAC6C,GAAE,OAAuB,IAAlBA,EAAGpE,YAAoBoE,EAAGnD,KAAKvB,EAAE,IAE7C,IAAwB,IAApByE,EACA,OAAO,EAMX,IAAwB,IAHDD,EAAMzD,aAAac,WACtC,SAAC8C,GAAE,OAAuB,IAAlBA,EAAGrE,YAAoBqE,EAAGpD,KAAKxB,EAAE,IAGzC,OAAO,EAIX,IAEyB,EAFnB6E,EAAWL,EAAMxD,aAAa8D,QAC9BC,EAAUF,EAASG,OAAON,EAAgB,GAAG,UAClCG,GAAQ,IAAzB,2BAA2B,CAAC,IAAjBI,EAAE,QACTlC,EAAa9C,GAAK8C,EAAa9C,GAAG2C,GAAGqC,EACzC,CAAC,+BAGD,OAFAlC,EAAa/C,GAAK,IAAIc,EAAkBiE,IAEjC,CACX,CAsBO,SAASG,EACZpC,EACAC,GAMA,IAJA,IAAMoC,EAAqB,IAAI9F,EAE3BgF,GAAa,EAERe,EAAO,EAAGA,EAAOrC,EAAaZ,OAAQiD,KAEtCtC,EAAWtB,KAAK4D,IACjBrC,EAAaqC,GAAMpE,aAAamB,QAAU,GAE1CgD,EAAmB5B,OAAO6B,GAEjC,IAE+C,EAF/C,UAEyBrC,EAAakB,WAAS,IAAhD,2BAAkD,CAAC,IAAD,qBAAtCjB,EAAG,KAAEG,EAAI,KACjB,KAAIA,EAAKnC,aAAamB,QAAU,IAAMW,EAAWtB,KAAKwB,IAAtD,CAGA,IACoC,EADhCP,EAAU3B,EAAAA,QAA0B,UACrBqC,EAAKnC,cAAY,IAApC,2BAAsC,CAAC,IAA5BoC,EAAI,QACX,GAAIA,EAAKiC,WAAWF,GAAqB,CACrCd,GAAa,EACb,IAEiC,EAF7BiB,EAAW,IAAIjG,EACfkG,GAAO,EAAM,UACKnC,EAAKC,QAAM,IAAjC,2BAAmC,CAAC,IAAzBmC,EAAO,QACd,GAAKL,EAAmB3D,KAAKgE,GAEtB,CACH,IAAMC,EAAW1C,EAAayC,GAE9B,GAAIC,EAASC,kBACT,SAGJ,GAAID,EAASvE,mBAAoB,CAC7BqE,GAAO,EACP,KACJ,CACAD,EAAWA,EAAS1C,GAAG6C,EAASzE,aAAa,GACjD,MAbIsE,EAAS/B,OAAOiC,EAcxB,CAAC,+BACID,GAASD,EAAS9D,KAAKwB,KACxBP,EAAUA,EAAQG,GAAG0C,GAE7B,MACI7C,EAAUA,EAAQG,GAAGQ,EAE7B,CAAC,+BAEDL,EAAaC,GAAOP,CAhCpB,CAiCJ,CAAC,+BACD,OAAO4B,CACX,C,ICpXYsB,E,WAGX,SAHWA,GAAAA,EAAE,UAAFA,EAAE,QAGb,CAHWA,IAAAA,EAAE,KAoBP,ICYHC,EDZSC,EAAiB,WAI1B,WAAYC,EAAeC,IAAW,oBAHtCA,UAAI,OACJD,WAAK,EAGDrG,KAAKqG,MAAQA,EACbrG,KAAKsG,KAAOA,CAChB,CAuLC,OAvLA,6BAUD,WACI,OAAOtG,KAAKsG,OAASJ,EAAGK,GAC5B,GAAC,kBAED,WACI,OAAOvG,KAAKsG,OAASJ,EAAGM,EAC5B,GAAC,oBAED,YAKoB,IAJhBC,EAAe,EAAfA,gBACAC,EAAU,EAAVA,WACAC,EAAc,EAAdA,eACAC,EAAS,EAATA,UAEMC,EAAmB,SAACC,EAAgBnB,GACtC,OAAIS,EAAkBW,aAAapB,GAQxB,CACHmB,YAAAA,EACAnB,KATgBA,EAAKqB,OAAO,CAC5BP,gBAAAA,EACAC,WAAAA,EACAC,eAAAA,EACAC,UAAAA,IAMAK,WAAW,GAGZ,CACHH,YAAAA,EACAnB,KAAAA,EACAsB,WAAW,EAEnB,EAEA,GAAIjH,KAAKkH,QACL,OAAOC,IAAAA,OACHnH,KAAKqG,OACL,SAACe,EAAKzB,GAAI,OAAKe,EACXG,EAAiBO,EAAKzB,GACzB,GACDc,GAIR,GAAIzG,KAAKqH,OACL,OAAOF,IAAAA,OACHnH,KAAKqG,OACL,SAACe,EAAKzB,GAAI,OAAKiB,EACXC,EAAiBO,EAAKzB,GACzB,GACDgB,GAGR,MAAMW,MAAM,iBAAD,OAAkBtH,KAAKsG,MACtC,GAAC,sBAED,SAASiB,GACL,OAAOvH,KAAKgH,OAAO,CACfP,iBAAiB,EACjBC,WAAY,gBAAGI,EAAW,EAAXA,YAAanB,EAAI,EAAJA,KAAMsB,EAAS,EAATA,UAAS,OAAOH,IAAgBG,EAAYtB,EAAO4B,EAAW5B,GAAM,EACtGgB,gBAAgB,EAChBC,UAAW,gBAAGE,EAAW,EAAXA,YAAanB,EAAI,EAAJA,KAAMsB,EAAS,EAATA,UAAS,OAAOH,IAAgBG,EAAYtB,EAAO4B,EAAW5B,GAAM,GAE7G,GAAC,sBAED,SAAS6B,GAGL,IAH8C,IAAjBC,EAAU,uDAAG,EACtCC,EAAoB1H,KAAK2H,UAEpBvF,EAAI,EAAGA,EAAIqF,EAAYrF,IAG5BsF,GADAA,GADAA,EAAoBA,EAAkBE,wBAAwBJ,IACxBK,2BAA2BL,IAC3BM,mBAAmBN,GAG7D,OAAOE,CACX,GAAC,0BAED,WACI,GAAI1H,KAAKkH,QACL,OAAOhB,EAAGM,GAEd,GAAIxG,KAAKqH,OACL,OAAOnB,EAAGK,IAEd,MAAMe,MAAM,wCAAD,OAAyCtH,KAAKsG,MAC7D,GAAC,uBAMD,SAAUyB,EAAuBC,GAC7B,IAAK5B,EAAkBW,aAAagB,IAAoB/H,KAAKsG,OAASyB,EAAgBzB,MAAQtG,KAAKqG,MAAM3D,SAAWqF,EAAgB1B,MAAM3D,OACtI,OAAO,EAGX,IAAMuF,EAAad,IAAAA,QAAUnH,KAAKqG,MAAO0B,EAAgB1B,OAAO,SAACV,EAAMuC,GACnE,OAAI9B,EAAkBW,aAAapB,GACxBA,EAAKwC,UAAUD,EAAWF,IAGjC5B,EAAkBW,aAAamB,IAG5BF,EAAcrC,EAAMuC,EAC/B,IACA,OAAOf,IAAAA,QAAUc,EACrB,GAAC,qBAED,WAA8B,IAAD,OACnBpC,EAAW7F,KAAKqG,MAAM+B,SAAQ,SAACzC,GACjC,IAAKS,EAAkBW,aAAapB,GAChC,OAAOA,EAEX,IAAM0C,EAAW1C,EAAKgC,UACtB,OAAIR,IAAAA,QAAUkB,EAAShC,OACZ,GAEPgC,EAAS/B,OAAS,EAAKA,MAAkC,IAA1B+B,EAAShC,MAAM3D,OACvC2F,EAAShC,MAEbgC,CACX,IAEA,GAAwB,IAApBxC,EAASnD,OAAc,CACvB,IAAM4F,EAAYnB,IAAAA,MAAQtB,GAC1B,GAAIO,EAAkBW,aAAauB,GAC/B,OAAOA,CAEf,CAEA,OAAO,IAAIlC,EAAkBP,EAAU7F,KAAKsG,KAChD,GAAC,mCAyCD,SAAsBiC,GAClB,OAAOpB,IAAAA,UAAY,CAAC,EAAGoB,GAAY,UAAIvI,KAAKsG,KAAOtG,KAAKqG,QAAS,SAACmC,EAAqBC,GACnF,GAAItB,IAAAA,QAAUqB,GACV,OAAOrB,IAAAA,OAASqB,EAAarB,IAAAA,OAASsB,GAAa,SAACrH,GAAK,OAAMgF,EAAkBW,aAAa3F,EAAM,IAG5G,GACJ,GAAC,2CAED,SAA8BoG,EAAwBe,GAA2B,IAAD,OACtE1C,EAAmB,GACnB6C,EAAqB1I,KAAK2I,sBAAsBJ,GAChDK,EAAgBzB,IAAAA,IAAMoB,EAAavI,KAAKsG,MACxCuC,EAAoB1B,IAAAA,IAAMoB,EAAavI,KAAK8I,gBAC9CC,GAAa,EA2BjB,GAzBA/I,KAAKqG,MAAM2C,SAAQ,SAACrD,GAChB,GAAIS,EAAkBW,aAAapB,GAAO,CACtC,MAGIA,EAAKsD,8BAA8BzB,EAASkB,GAFhCQ,EAAe,EAA3BC,WAIJ,GAHmC,EAA/BC,aAKA,OADAL,GAAa,GACN,EAEXlD,EAASpD,KAAKyG,EAClB,KAAO,CACH,GAAI9C,EAAkBiD,eAAeR,EAAmBlD,EAAM,EAAKmD,eAAgBtB,GAE/E,OADAuB,GAAa,GACN,EAGN3C,EAAkBiD,eAAeT,EAAejD,EAAM,EAAKW,KAAMkB,IAClE3B,EAASpD,KAAKkD,EAEtB,CACA,OAAO,CACX,IAEIoD,EACA,MAAO,CACHI,WAAY/C,EAAkBhC,MAC9BgF,cAAc,GAItB,IAAMD,EAAa/C,EAAkBkD,qBAAqBzD,EAAU7F,KAAKsG,MACzE,OAAIa,IAAAA,QAAUgC,EAAW9C,OACd,CACH8C,WAAY/C,EAAkBhC,MAC9BgF,cAAc,GAIf,CACHD,WAAAA,EACAC,cAAc,EAEtB,GAAC,qCAED,SAAwB5B,GAAyB,IAAD,EAK5C,OAJuBxH,KAAKiJ,8BAA8BzB,GAAO,eAC5DtB,EAAGK,IAAM,KAAE,SACXL,EAAGM,GAAK,IAAE,IAFP2C,UAKZ,GAAC,0BAED,SAAapB,EAAoCP,EAAwB+B,EAA4BC,GAA8B,IAAD,OAC9H,OAAIxJ,KAAKmI,UAAUJ,GAAiB,SAACpC,EAAMuC,GAAS,OAAKV,EAAQ7B,EAAMuC,IAAcV,EAAQU,EAAWvC,EAAK,IAClG4D,EAEJxB,EAAgB1B,MAAMoD,OAAM,SAACvB,GAChC,OAAI9B,EAAkBW,aAAamB,GACxB,EAAKwB,aAAaxB,EAAWV,GAAS,EAAMgC,GAEhDpD,EAAkBiD,eAAe,EAAKhD,MAAO6B,EAAWsB,EAAgBhC,EACnF,GACJ,GAAC,kCAED,SAAqB2B,EAA+BQ,EAAenC,GAAyB,IAAD,OACnFoC,GAAuB,EAoB3B,OAnBA5J,KAAKqG,MAAM2C,SAAQ,SAACd,EAAW2B,GAC3B,OAAIA,IAAeF,IAMf5B,EADA3B,EAAkBW,aAAamB,GACbA,EAEA9B,EAAkBhC,IAAI8D,IAGzBiB,EAAWO,aAAa3B,EAAiBP,EAASqC,EAAaF,EAAO,EAAKb,kBAE1Fc,GAAuB,GAChB,IAVX,IAAI7B,CAaR,IACO6B,CACX,GAAC,kDAED,SAAqCpC,GACjC,IAAM3B,EAAW7F,KAAKqG,MAAMxE,KAAI,SAAC8D,GAC7B,OAAIS,EAAkBW,aAAapB,GACxBA,EAAKkC,2BAA2BL,GAEpC7B,CACX,IACA,OAAOS,EAAkBkD,qBAAqBzD,EAAU7F,KAAKsG,KACjE,GAAC,wCAED,SAA2BkB,GACvB,IAAMsC,EAAmB9J,KAAK+J,qCAAqCvC,GAC7D3B,EAAWiE,EAAiBzD,MAAM1F,QAAO,SAACgF,EAAMgE,GAClD,IAAIR,EAOJ,OALIA,EADA/C,EAAkBW,aAAapB,GAClBA,EAEAS,EAAkBhC,IAAIuB,IAG/BmE,EAAiBF,qBAAqBT,EAAYQ,EAAOnC,EACrE,IAEA,GAAIxH,KAAKsG,OAASJ,EAAGM,IAAMX,EAASnD,QAAU,GAAKyE,IAAAA,MAAQA,IAAAA,IAAMtB,EAAUO,EAAkBW,eAAgB,CACzG,IAAMiD,EAAwB,GACxBC,EAAepE,EAMrB,GALAsB,IAAAA,QAAU8C,EAAa,GAAG5D,OAAO,SAACV,GAC1BwB,IAAAA,MAAQA,IAAAA,IAAM8C,GAAc,SAACvG,GAAI,OAAKyD,IAAAA,SAAWzD,EAAK2C,MAAOV,EAAK,MAClEqE,EAAcvH,KAAKkD,EAE3B,IACIqE,EAActH,OACd,OAAO,IAAI0D,EAAkB,GAAD,OAAK4D,EAAc,CAAC,IAAI5D,GAAkB,OAAKP,EAASlF,QAAO,SAACgF,GAAI,OAAMqE,EAAcE,SAASvE,EAAK,KAAK3F,KAAKsG,QAAQtG,KAAK8I,eAEjK,CACA,OAAO1C,EAAkBkD,qBAAqBzD,EAAU7F,KAAKsG,KACjE,GAAC,gCAED,SAAmBkB,GACf,IAAMsC,EAAmB9J,KAAK+J,qCAAqCvC,GACnE,GAAIsC,EAAiBzC,QAAUyC,EAAiBzD,MAAMoD,OAAM,SAACrH,GAAC,OAAMgE,EAAkBW,aAAa3E,IAAMA,EAAE8E,OAAO,IAAG,CAAC,IACzE,EADwE,UAC9F4C,EAAiBzD,OAAK,IAAzC,2BAA2C,CAAC,IAAjCV,EAAI,QACX,GAAKS,EAAkBW,aAAapB,GAApC,CAEC,IAC+B,EAD/B,UACqBA,EAAKU,OAAK,qBAAG,IAAxB8D,EAAO,QACd,GAAI/D,EAAkBW,aAAaoD,IAAYL,EAAiBzD,MAAMoD,OAAM,SAACvB,EAAWyB,GAAK,OAAMzB,EAAgC0B,qBAAqBO,EAASR,EAAOnC,EAAQ,IACzJ,OAAnB4C,QAAQC,IAAI,QAAO,GACZjE,EAAkBhC,IAAI+F,EAAS/D,EAAkBjD,GAAE,MAApBiD,GAAiB,OAAO0D,EAAiBzD,SAEvF,EALA,wEAKC,+BAND,CAOJ,CAAC,+BACL,CAEA,OAAOyD,CACX,IAAC,kBAxVD,WAA8B,IAAD,uBAAfzD,EAAK,yBAALA,EAAK,gBACf,OAAO,IAAID,EAAkBC,EAAOH,EAAGK,IAC3C,GAAC,gBAED,WAA6B,IAAD,uBAAfF,EAAK,yBAALA,EAAK,gBACd,OAAO,IAAID,EAAkBC,EAAOH,EAAGM,GAC3C,GAAC,0BA2FD,SAAoBb,GAChB,MAAuB,kBAATA,GAAqBA,aAAgBS,CACvD,GAAC,kCA6CD,SAA4BC,EAAeC,GACvC,OAAO,IAAIF,EAAkBC,EAAOC,GAAMqB,SAC9C,GAIA,4BACA,SAAsB2C,EAAyB3E,EAAc6D,EAAoBhC,GAAyB,IAAD,OACjG6B,GAAiB,EA4BrB,OA3BAiB,EAAgBtB,SAAQ,SAACd,GACrB,GAAI,EAAKnB,aAAamB,GAClB,OAAO,EAGX,OAAQsB,GACJ,KAAKtD,EAAGK,IAGJ,GAAIiB,EAAQU,EAAWvC,GAEnB,OADA0D,GAAiB,GACV,EAEX,MAEJ,KAAKnD,EAAGM,GAGJ,GAAIgB,EAAQ7B,EAAMuC,GAEd,OADAmB,GAAiB,GACV,EAKnB,OAAO,CACX,IACOA,CACX,KAAC,EA9LyB,GAoW9B,IElXO,SAASkB,EACZ7G,GAEA,IACuB,EADjBxB,EAAQ,GAAG,UACEwB,GAAI,IAAvB,2BAAyB,CAAC,IAEA,EAFfC,EAAI,QACLhB,EAAM,IAAI/C,EAAY,UACV+D,GAAI,IAAtB,2BAAwB,CAAC,IAAdzD,EAAG,QACVyC,EAAImB,OAAO5D,EACf,CAAC,+BACDgC,EAAMO,KAAKE,EACf,CAAC,+BACD,OAAO,IAAItB,EAAkBa,EACjC,CAQO,SAASsI,EACZ9G,GAEA,OAAO+G,EAAqB/G,EAChC,CAEA,SAAS+G,EAAqB9E,GAC1B,IAAIS,EAAAA,aAA+BT,GAc/B,OAAOA,EAbP,OAAQA,EAAKW,MACT,KAAKJ,EAAAA,IACD,MAAO,CACHI,KAAM,MACND,MAAOV,EAAKU,MAAMxE,IAAI4I,IAE9B,KAAKvE,EAAAA,GACD,MAAO,CACHI,KAAM,KACND,MAAOV,EAAKU,MAAMxE,IAAI4I,IAM1C,CDwFA,SAASC,EAAWnG,GAChB,OAAO,SAAChE,EAAWC,GAAe,IAAD,EAC7B,OAAOD,IAAMC,GAAKS,QAA2B,QAApB,EAACsD,EAAMoG,WAAWnK,UAAE,aAAnB,EAAqB0J,SAAS3J,GAC5D,CACJ,CAgBO,SAASqK,EACZrG,EACAsG,GAEA,GAAmB,IAAfA,EAAInI,OACJ,OAAO0D,EAAAA,KAGX,GAAmB,IAAfyE,EAAInI,QAAgBmI,EAAI,GAAGhI,UAC3B,OAAOuD,EAAAA,MAaX,GAAmB,IAAfyE,EAAInI,OACJ,OAAO0D,EAAAA,IAAAA,MAAAA,GAAiB,QACjB,OAAIyE,EAAI,GAAGjH,QAAQ/B,KAAI,SAACiJ,GAAC,OAAKvG,EAAMwG,SAASD,EAAE,MACpDE,SAASN,EAAWnG,IAG1B,IAM+B,EANzBhD,EAAe,IAAIF,EAAkBwJ,GAAKvG,mBAC3C/C,aAIL,UACmBA,GAAY,IAA/B,2BACI,IAD8B,IAAvBoC,EAAI,QACX,cAAsBA,EAAKC,QAAM,eAAG,CAAC,IAAD,EACmC,EAD5D1D,EAAG,eACmD,QADnD,EACcqE,EAAMoG,WAAWpG,EAAMwG,SAAS7K,WAAK,QAAI,IAAE,IAAnE,2BAAqE,CAAC,IAA3D+K,EAAS,QACVC,EAAe3G,EAAM4G,SAASF,GAChCC,IAAiBhL,GAAOyD,EAAK5B,KAAKmJ,IAClCvH,EAAK1B,SAAS/B,EAEtB,CAAC,iCACL,CAIJ,iCACA,IAC+B,EAD3B8J,EAAgB,IAAI/J,IAAYsB,EAAa,GAAGqC,QAAQ,UACzCrC,GAAY,IAA/B,2BAAiC,CAAC,IAAvBoC,EAAI,QACXqG,EAAgB,IAAI/J,KAEhB,OAAI0D,EAAKC,QAAQjD,QAAO,SAACH,GAAC,OAAKwJ,EAAc5J,IAAII,EAAE,IAE3D,CAEA,iCACA,IAE+B,EAFzB4K,EAAY,IAAInL,IAAc,UAEjBsB,GAAY,IAA/B,2BAAiC,CAAC,IACC,EADxBoC,EAAI,kBACOqG,GAAa,IAA/B,2BAAiC,CAAC,IAAvB9J,EAAG,QACVyD,EAAK1B,SAAS/B,EAClB,CAAC,qCAC4B,EAD5B,UACiByD,EAAKC,QAAM,IAA7B,2BAA+B,CAAC,IAArB1D,EAAG,QACVkL,EAAUjL,IAAID,EAClB,CAAC,iCACL,CAEA,iCACA,IAAMmL,EAAUC,EACZ/J,GAAa,OACT6J,GACJ,IAAIxL,GACNe,QAAO,SAAC4K,GAAC,OAAMA,EAAEC,SAAS3I,SAAS,IAG/B4I,EAAUJ,EAAQrE,QAAoB,SAACI,EAAKsE,GAAY,IACzB,EADwB,UACrCA,EAAOA,QAAM,qBAAG,IAAzBC,EAAK,QACPvE,EAAIxE,MAAK,SAACgJ,GAAI,OAAKD,EAAME,OAAOD,EAAK,KACtCxE,EAAI3E,KAAKkJ,EAEjB,EAJA,8BAIC,iCACD,OAAOvE,CACX,GAAG,IAGG0E,EAAOT,EAEb,GAAIS,EAAKpJ,OAAS,GAAK+I,EAAQ/I,OAAS,EAAG,CAEvC,IAGiD,EAH3CqJ,EAASC,MAAiBF,EAAKpJ,QAChCuJ,KAAK,IACLpK,KAAI,kBAAMmK,MAAaP,EAAQ/I,QAAQuJ,KAAK,EAAE,IAAE,UACrBR,EAAQjH,WAAS,qBAAG,IACJ,EADG,qBAAvC0H,EAAG,KAAEC,EAAU,eACOL,EAAKtH,WAAS,IAA5C,2BAA8C,CAAC,IAAD,qBAAlC4H,EAAG,KAAU,KACRV,OAAO9I,MAAK,SAAC+I,GAAK,OAAKA,EAAME,OAAOM,EAAW,MACxDJ,EAAOK,GAAKF,GAAO,EAE3B,CAAC,iCACL,EANA,8BAQA,iCACA,IAAMG,EAAY,SAACD,GAAW,OAAKN,EAAKM,GAAKZ,SAAS1K,WAAa,CAAE,EAC/DwL,EAAY,SAACJ,GAAW,OAAKT,EAAQS,GAAKpL,UAAW,EAIrDyL,EAAgB,SAACC,EAAoBC,GAAkB,OACzDtF,IAAAA,MAAQqF,GAAU,SAACJ,GAAG,OAClBjF,IAAAA,MAAQsF,GAAU,SAACP,GAAG,OAClBH,EAAOK,GAAKF,GANV,SAACA,EAAaE,GAAW,OACnCN,EAAKM,GAAKZ,SAASrI,GAAGsI,EAAQS,IAAMpL,UAAW,CAKpBM,CAAM8K,EAAKE,GAAO,CAAC,GACzC,IAELjF,IAAAA,MAAQqF,EAAUH,GAClBlF,IAAAA,MAAQsF,EAAUH,EAAW,EAK3BI,EAAmC,GAYzC,GAgDR,SACIC,EACAC,EACAb,EACAc,GAMA,IACyB,EADzB,UACkBF,GAAO,qBAAG,IAAjBP,EAAG,QACJU,EAAOF,EAAQjM,QAAO,SAACuL,GAAG,OAAKH,EAAOK,GAAKF,EAAI,IAEjDY,EAAKpK,SACJiK,EAAQ/J,MACL,SAACmK,GAAQ,OACLA,IAAaX,GACbQ,EAAQnD,OACJ,SAACuD,GAAQ,OACJF,EAAK5C,SAAS8C,IACfjB,EAAOgB,GAAUC,EAAS,GACjC,KAGTH,EAAS,CAACT,GAAMU,EAExB,EAhBA,8BAgBC,qCAEwB,EAFxB,UAEiBF,GAAO,qBAAG,IAAjBV,EAAG,QACJY,EAAOH,EAAQhM,QAAO,SAACyL,GAAG,OAAKL,EAAOK,GAAKF,EAAI,IAEjDY,EAAKpK,SACJkK,EAAQhK,MACL,SAACoK,GAAQ,OACLA,IAAad,GACbS,EAAQlD,OACJ,SAACsD,GAAQ,OACJD,EAAK5C,SAAS6C,IACfhB,EAAOgB,GAAUC,EAAS,GACjC,KAGTH,EAASC,EAAM,CAACZ,GAExB,EAhBA,8BAgBC,iCACDe,EAAuBN,EAASC,EAASb,EAAQ,EAAG,GAAI,GAAIc,EAChE,CA1GQK,CACIpB,EAAKjK,KAAI,SAACsL,EAAM5J,GAAG,OAAKA,CAAG,IAC3BkI,EAAQ5J,KAAI,SAACsL,EAAM5J,GAAG,OAAKA,CAAG,IAC9BwI,GACA,SAACD,EAAMsB,GAGH,OAFAV,EAASjK,KAAK,CAACqJ,EAAMsB,KAEd,CACX,IAGAV,EAAShK,OAAQ,CACjB,MAAqByE,IAAAA,MAAQuF,GAAU,+BAAEZ,EAAI,KAAEsB,EAAI,YAC/Cb,EAAcT,EAAMsB,EAAK,IAGvBC,GAFL,YAFgB,GAIQxL,KAAI,SAACqK,GAAG,OAAKT,EAAQS,EAAI,IAIlD,EAAgCoB,EAC5B/L,EACA8L,GAFIE,GAAQ,EAARA,SAAUC,GAAS,EAATA,UAQZC,GAAc,IAAIpM,EACpBkM,IACFjJ,mBACIoJ,IAAmB,OAAI1D,GAAenI,KACxC,SAAC8L,GAAC,OAAKpJ,EAAMwG,SAAS4C,EAAE,IAEtBC,GAAUxH,EAAAA,IACZwE,EAAqBrG,EAAOkJ,GAAYlM,cACxCqJ,EAAqBrG,EAAO8I,IAE1BQ,GAAMzH,EAAAA,GACRwH,GACAhD,EAAqBrG,EAAOiJ,KAIhC,OAAOpH,EAAAA,IAAAA,MAAAA,GAAiB,OAAQsH,IAAQ,QAAEG,MAAK7C,SAC3CN,EAAWnG,GAEnB,CACJ,CAGA,OAAO6B,EAAAA,IAAAA,MAAAA,GAAiB,QACjB,OAAI4D,GAAenI,KAAI,SAACO,GAAC,OAAKmC,EAAMwG,SAAS3I,EAAE,KAAC,QACnDgE,EAAAA,GAAAA,MAAAA,GAAiB,OACV7E,EAAaM,KAAI,SAACC,GAAC,OA2LlC,SACIyC,EACA5B,GAEA,OAAOyD,EAAAA,IAAAA,MAAAA,GAAiB,QACjB,OAAIzD,EAAIiB,QAAQ/B,KAAI,SAACiJ,GAAC,OAAKvG,EAAMwG,SAASD,EAAE,KAEvD,CAlMuCgD,CAAqBvJ,EAAOzC,EAAE,SAE/DkJ,SAASN,EAAWnG,GAC1B,CAmDA,SAAS0I,EACLN,EACAC,EACAb,EACApC,EAEAoE,EACAtB,EACAI,GACD,IACwB,EADzB,UACkBD,GAAO,qBAAG,IAAf9K,EAAC,QACR,GAAIA,GAAK6H,GAASgD,EAAQhM,QAAO,SAACyL,GAAG,OAAKL,EAAOK,GAAKtK,EAAE,IAAEY,QAAU,EAAG,CAEnE,IAOwB,EAPlBsL,EAAKjC,EAAOlK,KAAI,SAACuK,EAAK6B,GAAQ,OAChClC,EAAOkC,GAAUnM,GAAKsK,EAAI/G,QAAU+G,EAAIvK,KAAI,kBAAM,CAAC,GAAU,IAE3DqM,EAAYvB,EAAQhM,QAAO,SAACyL,GAAG,OAAKL,EAAOK,GAAKtK,EAAE,IAClDqM,EAAY1B,EAASpH,QAEvB+I,GAAQ,EAAM,UACDxB,GAAO,qBAAG,IAAhByB,EAAE,QACT,GACI1B,EAAQhM,QAAO,SAACyL,GAAG,OAAK4B,EAAG5B,GAAKiC,EAAG,IAAE3L,SACrCiK,EAAQhM,QAAO,SAACyL,GAAG,OAAKL,EAAOK,GAAKtK,EAAE,IAAEY,OAC1C,CACE,GAAI2L,EAAKvM,EACQ,OAAbsM,GAAQ,EAAK,QAGbD,EAAU1L,KAAK4L,GAAI,IACM,EADN,UACD1B,GAAO,IAAzB,2BAA2B,CAAC,IAAjBP,EAAG,QACV4B,EAAG5B,GAAKiC,GAAM,CAClB,CAAC,+BAET,CACJ,EAfA,6CAOY,KAAM,CAQjB,+BAED,IAAKD,EACavB,EAASqB,EAAWC,IAE9BlB,EACIN,EACAC,EACAoB,EACAlM,EACAoM,EACAC,EACAtB,EAIhB,CACJ,EA1CA,8BA0CC,+BACL,CAEA,SAASvB,EACLgD,EACAlD,EACAmD,GAG+C,IAEH,EAJ5CC,EAA0B,uDAAG,GAC7BC,EAAM,uDAAG,EAEHpD,EAAU,GAAG,UACMD,EAAU5G,WAAS,qBAAG,IAAD,qBAAlCjB,EAAG,KAAErD,EAAG,KAChB,GAAIqD,EAAMkL,EAAS,MAAD,WAGlB,IAAMC,EAAIJ,EAAM3N,QAAO,SAACmB,GAAC,OAAKA,EAAEC,KAAK7B,EAAI,IACzC,GAAIwO,EAAEhM,QAAU,EAAG,CACf,IAU4B,EAVtBiM,EAAKD,EAAE1H,QAAO,SAACI,EAAKtF,GAAC,OAAKsF,EAAIhD,IAAItC,EAAE,GAAE4M,EAAE,IACxCE,EAAUL,EAAapL,GAAGwL,GAE1BE,EAAavD,EADNgC,EAAkBgB,EAAO,CAACK,IAAKpB,SAGxCnC,EACAwD,EACAJ,EACAjL,EAAM,GACR,UACgBsL,GAAU,qBAAG,IAApBC,EAAG,QAELN,EAAc5L,MAAK,SAACmM,GAAM,OAAKA,EAAOlD,OAAOiD,EAAItD,SAAS,MAE3DgD,EAAc/L,KAAKqM,EAAItD,UACvBH,EAAQ5I,KAAKqM,GAErB,EAPA,8BAOC,+BACL,CACJ,EAzBA,8BAyBC,+BASD,OAPKN,EAAc5L,MAAK,SAACmM,GAAM,OAAKA,EAAOlD,OAAO0C,EAAa,KAC3DlD,EAAQ5I,KAAK,CACTiJ,OAAQ4C,EACR9C,SAAU+C,EAAavM,UAIxBqJ,CACX,CAEA,SAASiC,EACL5J,EACA2J,GAEA,IAAIE,EACyB,EADS,UAChBF,GAAO,qBAAG,IAArB2B,EAAO,QACRlN,EAAI4B,EACL/C,QAAO,SAACmB,GAAC,OAAKkN,EAAQzM,WAAWT,EAAE,IACnCD,KAAI,SAACC,GAAC,OAAKA,EAAEE,OAAO,IACzB,GAAiB,IAAbF,EAAEY,OAAe,MAAD,GACT,CAAE6K,SAAU,GAAIC,UAAW9J,IACrC,IACiB,EADjB,UACgB5B,GAAC,IAAlB,2BAAoB,CAAC,IACe,EADzBmN,EAAE,kBACSD,EAAQpL,QAAM,IAAhC,2BAAkC,CAAC,IAAxB1D,EAAG,QACV+O,EAAGhN,SAAS/B,EAChB,CAAC,+BACL,CAAC,+BAIGqN,EAHCA,EAGUA,EAAS5M,QAAO,SAACuO,GAAE,OAAKpN,EAAEc,MAAK,SAACuM,GAAE,OAAKA,EAAGtD,OAAOqD,EAAG,GAAC,IAFrDpN,CAInB,EAjBA,wEAiBC,+BAED,IAAMsN,EAAK,IAAI/N,EAAkBkM,GAC5BnJ,IAAI,IAAI/C,EAAkBgM,IAC1B/I,mBACCkJ,EAAY9J,EAAK/C,QACnB,SAAC0O,GAAC,OAAMD,EAAG7N,aAAaqB,MAAK,SAACwM,GAAE,OAAKA,EAAG7M,WAAW8M,EAAE,GAAC,IAE1D,MAAO,CAAE9B,SAAUA,EAAWC,UAAAA,EAClC,CAjeApD,QAAQC,IAAI,sBAEZiF,UAAY,SAACC,GACT,IAAMC,EAAQC,YAAYC,MAC1B,OAAQH,EAAGxP,KAAKuG,MACZ,IAAK,aACD,IACoC,EAD9BjD,EAAa,IAAIzD,EAAY,UACjB2P,EAAGxP,KAAKsD,YAAU,IAApC,2BAAsC,CAAC,IAA5BnD,EAAG,QACVmD,EAAWS,OAAO5D,EACtB,CAAC,+BACDiG,EAAI,CACA5B,MAAOgL,EAAGxP,KAAKwE,MACflB,WAAAA,EACAsM,QAAS,IAAI1P,IACbqD,aAAciM,EAAGxP,KAAKuD,aAAazB,IAC/B0I,IAIR,GAII,IADAjG,EAAiB6B,EAAE7C,cACZmC,EAAgBU,EAAE9C,WAAY8C,EAAE7C,eACnCgB,EAAiB6B,EAAE7C,oBAElBmB,EAAkB0B,EAAE9C,WAAY8C,EAAE7C,eAC3C8G,QAAQC,IAAI,SAAU,wCAAyCoF,YAAYC,MAAQF,EAAO,MAC1F,MAEJ,IAAK,UACD,IAAKrJ,EACD,MAAM,IAAImB,MAAM,qCAEpB,IAAM5D,EAUlB,SAAiBkM,GACb,IAAM1P,EAAMiG,EAAE5B,MAAM4G,SAASyE,GAOzBC,EAA6B,EACjC,KAAOA,EAA6B,GAAG,CACnC,IAAMC,EAAgB1M,EAClB+C,EAAE9C,WACF8C,EAAE7C,aACFpD,EACAiG,EAAEwJ,SAGN,IAAIG,GAAkBA,EAAcjN,UAuBhC,MAvB4C,IACI,EADL,UACfiN,EAAclM,QAAM,IAAhD,2BAAkD,CAAC,IAAxCmM,EAAa,QACpB,IACK5J,EAAE9C,WAAWtB,KAAKgO,KAClB5J,EAAEwJ,QAAQvP,IAAI2P,GACjB,CAKE,IAAMP,EAAQC,YAAYC,MAC1BvJ,EAAE7C,aAAayM,GAAiBhM,EAC5BoC,EAAE9C,WACF8C,EAAE7C,aACFyM,GAEJ3F,QAAQC,IAAI,KAAM,SAAU,eAAgBlE,EAAE5B,MAAMwG,SAASgF,GAAgB,OAAQN,YAAYC,MAAQF,EAAO,MAChHrJ,EAAEwJ,QAAQxP,IAAI4P,GACdF,GAA8B,CAClC,CACJ,CAAC,+BAKT,CAEA,IAAML,EAAQC,YAAYC,MACpBM,EAAiBjM,EACnBoC,EAAE9C,WACF8C,EAAE7C,aACFpD,GAEJkK,QAAQC,IAAI,KAAM,SAAU,YAAalE,EAAE5B,MAAMwG,SAAS7K,GAAM,OAAQuP,YAAYC,MAAQF,EAAO,MACnGrJ,EAAE7C,aAAapD,GAAO8P,EAEtB,IAAMC,EAAgBR,YAAYC,MAC5B9K,EAAagG,EAAqBzE,EAAE5B,MAAOyL,EAAezO,cAEhE,OADA6I,QAAQC,IAAI,KAAM,SAAU,mBAAoBoF,YAAYC,MAAQO,EAAe,MAC5ErL,CACX,CAnEyBsL,CAAQX,EAAGxP,KAAK6P,SAC7BxF,QAAQC,IAAI,SAAU,iBAAkBkF,EAAGxP,KAAK6P,QAAS,MAAOH,YAAYC,MAAQF,EAAO,MAC3FW,YAAY,CACRP,QAASL,EAAGxP,KAAK6P,QACjBzG,WAAYqB,EAA2B9G,KAIvD,C,GE7EI0M,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaE,QAGrB,IAAIC,EAASN,EAAyBE,GAAY,CACjDK,GAAIL,EACJM,QAAQ,EACRH,QAAS,CAAC,GAUX,OANAI,EAAoBP,GAAUQ,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASJ,GAG3EK,EAAOE,QAAS,EAGTF,EAAOD,OACf,CAGAJ,EAAoBU,EAAIF,EAGxBR,EAAoBvF,EAAI,WAGvB,IAAIkG,EAAsBX,EAAoBY,OAAET,EAAW,CAAC,MAAM,WAAa,OAAOH,EAAoB,KAAO,IAEjH,OADAW,EAAsBX,EAAoBY,EAAED,EAE7C,E,WCrCA,IAAIE,EAAW,GACfb,EAAoBY,EAAI,SAASjN,EAAQmN,EAAUC,EAAIC,GACtD,IAAGF,EAAH,CAMA,IAAIG,EAAeC,IACnB,IAASnP,EAAI,EAAGA,EAAI8O,EAASxO,OAAQN,IAAK,CACrC+O,EAAWD,EAAS9O,GAAG,GACvBgP,EAAKF,EAAS9O,GAAG,GACjBiP,EAAWH,EAAS9O,GAAG,GAE3B,IAJA,IAGIoP,GAAY,EACPC,EAAI,EAAGA,EAAIN,EAASzO,OAAQ+O,MACpB,EAAXJ,GAAsBC,GAAgBD,IAAaK,OAAOC,KAAKtB,EAAoBY,GAAGxH,OAAM,SAASmI,GAAO,OAAOvB,EAAoBY,EAAEW,GAAKT,EAASM,GAAK,IAChKN,EAAS5L,OAAOkM,IAAK,IAErBD,GAAY,EACTH,EAAWC,IAAcA,EAAeD,IAG7C,GAAGG,EAAW,CACbN,EAAS3L,OAAOnD,IAAK,GACrB,IAAIc,EAAIkO,SACEZ,IAANtN,IAAiBc,EAASd,EAC/B,CACD,CACA,OAAOc,CArBP,CAJCqN,EAAWA,GAAY,EACvB,IAAI,IAAIjP,EAAI8O,EAASxO,OAAQN,EAAI,GAAK8O,EAAS9O,EAAI,GAAG,GAAKiP,EAAUjP,IAAK8O,EAAS9O,GAAK8O,EAAS9O,EAAI,GACrG8O,EAAS9O,GAAK,CAAC+O,EAAUC,EAAIC,EAwB/B,C,IC5BAhB,EAAoBwB,EAAI,SAASnB,GAChC,IAAIoB,EAASpB,GAAUA,EAAOqB,WAC7B,WAAa,OAAOrB,EAAgB,OAAG,EACvC,WAAa,OAAOA,CAAQ,EAE7B,OADAL,EAAoB2B,EAAEF,EAAQ,CAAEvR,EAAGuR,IAC5BA,CACR,ECNAzB,EAAoB2B,EAAI,SAASvB,EAASwB,GACzC,IAAI,IAAIL,KAAOK,EACX5B,EAAoB6B,EAAED,EAAYL,KAASvB,EAAoB6B,EAAEzB,EAASmB,IAC5EF,OAAOS,eAAe1B,EAASmB,EAAK,CAAEQ,YAAY,EAAMC,IAAKJ,EAAWL,IAG3E,ECPAvB,EAAoB1C,EAAI,CAAC,EAGzB0C,EAAoBhB,EAAI,SAASiD,GAChC,OAAOC,QAAQC,IAAId,OAAOC,KAAKtB,EAAoB1C,GAAG3G,QAAO,SAASyL,EAAUb,GAE/E,OADAvB,EAAoB1C,EAAEiE,GAAKU,EAASG,GAC7BA,CACR,GAAG,IACJ,ECPApC,EAAoBqC,EAAI,SAASJ,GAEhC,MAAO,aAAeA,EAAf,oBACR,ECHAjC,EAAoBsC,SAAW,SAASL,GAGxC,ECJAjC,EAAoBlK,EAAI,WACvB,GAA0B,kBAAfyM,WAAyB,OAAOA,WAC3C,IACC,OAAO5S,MAAQ,IAAI6S,SAAS,cAAb,EAGhB,CAFE,MAAOxD,GACR,GAAsB,kBAAXyD,OAAqB,OAAOA,MACxC,CACA,CAPuB,GCAxBzC,EAAoB6B,EAAI,SAASa,EAAKC,GAAQ,OAAOtB,OAAOuB,UAAUC,eAAepC,KAAKiC,EAAKC,EAAO,ECAtG3C,EAAoB8C,IAAM,SAASzC,GAGlC,OAFAA,EAAO0C,MAAQ,GACV1C,EAAO2C,WAAU3C,EAAO2C,SAAW,IACjC3C,CACR,ECJAL,EAAoBiD,EAAI,W,WCIxB,IAAIC,EAAkB,CACrB,IAAK,GAkBNlD,EAAoB1C,EAAEvL,EAAI,SAASkQ,EAASG,GAEvCc,EAAgBjB,IAElBkB,cAAcnD,EAAoBiD,EAAIjD,EAAoBqC,EAAEJ,GAG/D,EAEA,IAAImB,EAAqBC,KAA0C,oCAAIA,KAA0C,qCAAK,GAClHC,EAA6BF,EAAmBhR,KAAKmR,KAAKH,GAC9DA,EAAmBhR,KAzBA,SAAS1C,GAC3B,IAAIoR,EAAWpR,EAAK,GAChB8T,EAAc9T,EAAK,GACnB+T,EAAU/T,EAAK,GACnB,IAAI,IAAIuQ,KAAYuD,EAChBxD,EAAoB6B,EAAE2B,EAAavD,KACrCD,EAAoBU,EAAET,GAAYuD,EAAYvD,IAIhD,IADGwD,GAASA,EAAQzD,GACdc,EAASzO,QACd6Q,EAAgBpC,EAAS4C,OAAS,EACnCJ,EAA2B5T,EAC5B,C,eCtBA,IAAIoB,EAAOkP,EAAoBvF,EAC/BuF,EAAoBvF,EAAI,WACvB,OAAOuF,EAAoBhB,EAAE,KAAK2E,KAAK7S,EACxC,C,ICF0BkP,EAAoBvF,G","sources":["logic/bitlogic/BitVector.ts","logic/bitlogic/LogicalExpression.ts","logic/bitlogic/BitLogic.ts","logic/booleanlogic/BooleanExpression.ts","tooltips/worker/Worker.ts","tooltips/worker/Utils.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["const ONE = BigInt(1);\nconst ZERO = BigInt(0);\n\nfunction intersection<T>(a: Set<T>, b: Set<T>): Set<T> {\n    if (a.size > b.size) {\n        const tmp = a;\n        // eslint-disable-next-line no-param-reassign\n        a = b;\n        // eslint-disable-next-line no-param-reassign\n        b = tmp;\n    }\n    return new Set([...a].filter((v) => b.has(v)));\n}\n\nfunction union<T>(a: Set<T>, b: Set<T>): Set<T> {\n    return new Set([...a, ...b]);\n}\n\n/**\n * A fixed-size bit vector.\n */\nexport class BitVector {\n    data: bigint;\n    intSet: Set<number>;\n\n    constructor();\n    constructor(bits: bigint, intSet: Set<number>);\n\n    constructor(bits?: bigint, intSet?: Set<number>) {\n        this.data = bits ?? ZERO;\n        this.intSet = intSet ?? new Set();\n    }\n\n    /** Sets the bit `bit` in this BitVector, if not already set. */\n    setBit(bit: number): this {\n        this.data |= ONE << BigInt(bit);\n        this.intSet.add(bit);\n        return this;\n    }\n\n    /** Clears the bit `bit` in this BitVector, if set. */\n    clearBit(bit: number): this {\n        if (this.intSet.has(bit)) {\n            this.data = this.data - (ONE << BigInt(bit));\n            this.intSet.delete(bit);\n        }\n        return this;\n    }\n\n    /** Creates a new BitVector consisting of the bits that are both in `this` and `other`. */\n    and(other: BitVector) {\n        return new BitVector(other.data & this.data, intersection(other.intSet, this.intSet));\n    }\n\n    /** Creates a new BitVector consisting of the bits that are in `this` or in `other`. */\n    or(other: BitVector) {\n        return new BitVector(other.data | this.data, union(other.intSet, this.intSet));\n    }\n\n    /** Returns true iff `bit` is set in this BitVector. */\n    test(bit: number) {\n        return this.intSet.has(bit);\n    }\n\n    /** Returns true iff all the bits in `this` are also set in `other`. */\n    isSubsetOf(other: BitVector) {\n        return this.numSetBits <= other.numSetBits && (this.data | other.data) === other.data;\n    }\n\n    /** Returns true iff all the bits in `this` are also set in `other` and the other way around. */\n    equals(other: BitVector) {\n        return this.data === other.data;\n    }\n\n    /**\n     * slow\n     */\n    toString(domainSize: number) {\n        let str = \"\";\n        for (let bit = domainSize - 1; bit >= 0; bit--) {\n            if (this.data & (ONE << BigInt(bit))) {\n                str += '1';\n            } else {\n                str += '0';\n            }\n        }\n        return str;\n    }\n\n    /** Returns a new BitVector with exactly the same bits set. */\n    clone() {\n        return new BitVector(this.data, new Set(this.intSet));\n    }\n\n    /** Returns true iff no bits are set. */\n    isEmpty() {\n        return this.numSetBits === 0;\n    }\n\n    /** Returns true iff there is a bit that's set in both `this` and `other`. */\n    intersects(other: BitVector) {\n        return Boolean(this.data & other.data);\n    }\n\n    /** Iterates over all set bits in this BitVector. */\n    iter(): IterableIterator<number> {\n        return this.intSet.values()\n    }\n\n    /** Assuming that this vector has a single set bit, returns it. */\n    getSingleSetBit(): number {\n        return this.intSet.values().next().value as number\n    }\n\n    /** Returns the number of bits set in this BitVector. */\n    get numSetBits() {\n        return this.intSet.size\n    }\n}","import { BitVector } from './BitVector';\n\n/**\n * A logical expression in DNF (disjunctive normal form).\n */\nexport class LogicalExpression {\n    conjunctions: BitVector[];\n\n    /** Creates an expression that always evaluates to false. */\n    static false() {\n        return new LogicalExpression([]);\n    }\n\n    /** Creates an expression that always evaluates to true. */\n    static true() {\n        return new LogicalExpression([new BitVector()]);\n    }\n\n    /** Constructs an expression from the given BitVectors describing a DNF expression. */\n    constructor(conjs: BitVector[]) {\n        this.conjunctions = conjs;\n    }\n\n    /**\n     * Constructs an expression that evaluates to true if `this`\n     * evaluates to true or `other` evaluates to true.\n     */\n    or(other: LogicalExpression | BitVector) {\n        if (other instanceof BitVector) {\n            return new LogicalExpression([...this.conjunctions, other]);\n        } else {\n            return new LogicalExpression([\n                ...this.conjunctions,\n                ...other.conjunctions,\n            ]);\n        }\n    }\n\n    /**\n     * Constructs an expression that evaluates to true if `this`\n     * evaluates to true and `other` evaluates to true.\n     */\n    and(other: LogicalExpression | BitVector) {\n        if (other instanceof BitVector) {\n            return new LogicalExpression(\n                andToDnf2(this.conjunctions, [other]),\n            );\n        }\n\n        if (this.isTriviallyFalse() || other.isTriviallyFalse()) {\n            return LogicalExpression.false();\n        }\n        return new LogicalExpression(\n            andToDnf2(this.conjunctions, other.conjunctions),\n        );\n    }\n\n    /**\n     * From each conjunction in the DNF, removes `drop` unless the\n     * `unless` bit is set.\n     */\n    drop_unless(drop: number, unless: number) {\n        return new LogicalExpression(\n            this.conjunctions.map((c) =>\n                c.test(unless) ? c : c.clone().clearBit(drop),\n            ),\n        );\n    }\n\n    /**\n     * Simplifies the expression by removing disjuncts that are implied by a another disjunct.\n     */\n    removeDuplicates() {\n        const terms: BitVector[] = [];\n        for (let i = 0; i < this.conjunctions.length; i++) {\n            const candidate = this.conjunctions[i];\n            const weakerTerm = terms.findIndex((t) => t.isSubsetOf(candidate));\n            if (weakerTerm !== -1) {\n                continue;\n            }\n\n            const strongerTerm = terms.findIndex((t) =>\n                candidate.isSubsetOf(t),\n            );\n            if (strongerTerm !== -1) {\n                terms[strongerTerm] = candidate;\n            } else {\n                terms.push(candidate);\n            }\n        }\n        return new LogicalExpression(terms);\n    }\n\n    /**\n     * Evaluates the expression assuming the variables in `vec` are true.\n     */\n    eval(vec: BitVector) {\n        return this.conjunctions.some((c) => c.isSubsetOf(vec));\n    }\n\n    /**\n     * Whether the expression always definitely evaluates to false.\n     */\n    isTriviallyFalse() {\n        return this.conjunctions.length === 0;\n    }\n\n    /**\n     * Whether the expression always definitely evaluates to true.\n     */\n    isTriviallyTrue() {\n        return (\n            this.conjunctions.length > 0 &&\n            this.conjunctions.some((c) => c.isEmpty())\n        );\n    }\n}\n\n/**\n * An optimized (unrolled) version of `andToDnf` for AND-ing exactly two expressions.\n */\nfunction andToDnf2(left: BitVector[], right: BitVector[]): BitVector[] {\n    const newExpr = [];\n    for (const l of left) {\n        for (const r of right) {\n            newExpr.push(l.or(r));\n        }\n    }\n    return newExpr;\n}\n\nexport function andToDnf(arr: BitVector[][]): BitVector[] {\n    if (arr.length === 2) {\n        return andToDnf2(arr[0], arr[1]);\n    }\n    const newExpr = [];\n    for (const tuple of cartesianProduct(...arr)) {\n        const newVec = tuple.reduce(\n            (acc, val) => acc.or(val),\n            new BitVector(),\n        );\n        newExpr.push(newVec);\n    }\n    return newExpr;\n}\n\nfunction cartesianProduct<T>(...allEntries: T[][]): T[][] {\n    return allEntries.reduce<T[][]>(\n        (results, entries) =>\n            results\n                .map((result) => entries.map((entry) => result.concat([entry])))\n                .reduce((subResults, result) => subResults.concat(result), []),\n        [[]],\n    );\n}\n","import { LogicalExpression } from './LogicalExpression';\nimport { BitVector } from './BitVector';\n\n/**\n * Requirements are a partial logic that makes statements about the present bits\n * and no statements about absent bits.\n */\nexport type Requirements = Record<number, LogicalExpression>;\n/**\n * A BitLogic models a least fixed-point logic (LFP).\n * Since every LogicalExpression can only mention terms positively\n * (no negation, no quantifiers) this least fixed-point always exists.\n */\nexport type BitLogic = LogicalExpression[];\n\nexport function mergeRequirements(numBits: number, ...reqs: Requirements[]): BitLogic {\n    const requirements: LogicalExpression[] = [];\n    const mergedRequirements: Requirements = {};\n    Object.assign(mergedRequirements, ...reqs);\n    for (let i = 0; i < numBits; i++) {\n        requirements.push(mergedRequirements[i] ?? LogicalExpression.false());\n    }\n    return requirements;\n}\n\n\n/* \n * Returns the least fixed-point of the given requirements,\n * which can be interpreted as the logical result of the given requirements.\n * This is a BitVector from which no new facts can be derived.\n */\nexport function computeLeastFixedPoint(\n    /** Why is this being computed? For logging */\n    reason: string,\n    /** The BitLogic describing the logic program (requirements). */\n    logic: BitLogic,\n    /**\n     * To resume computation from an earlier result after adding facts to `additionalRequirements`\n     * (concretely: semilogic requirements), pass startingBits. Purely a performance optimization.\n     */\n    startingBits?: BitVector,\n) {\n    // This is an extremely simple iterate-to-fixpoint solver in O(n^2).\n    // There are better algorithms but this usually converges after\n    // about 15 rounds.\n    const bits = startingBits?.clone() ?? new BitVector();\n    let changed = true;\n    let iterations = 0;\n    const start = performance.now();\n    while (changed) {\n        changed = false;\n        for (const [idx, expr] of logic.entries()) {\n            const evaluate = (e: LogicalExpression) => {\n                const val = e.eval(bits);\n                if (val) {\n                    bits.setBit(idx);\n                    return true;\n                }\n                return false;\n            };\n\n            if (expr.isTriviallyFalse()) {\n                continue;\n            } else if (!bits.test(idx)) {\n                const didChange = evaluate(expr);\n                changed ||= didChange;\n            }\n        }\n        iterations++;\n    }\n    console.log(\n        reason,\n        'fixpoint iteration took',\n        performance.now() - start,\n        'ms for',\n        iterations,\n        'iterations',\n    );\n\n    return bits;\n}\n\n/**\n * Some requirements still have some relatively deep expressions, and the `computeGroundExpression` algorithm may perform poorly\n * if it repeately has to reveal a complex entrance. Finding *any* path to the check has a reasonably likelyhood\n * of including these bottlenecks, and precomputing bits in that partial path can solve a lot of problems and the\n * results can even be reused.\n */\nexport function findNewSubgoals(\n    /** Do not reveal these bits */\n    opaqueBits: BitVector,\n    /** Traverse these requirements... */\n    requirements: LogicalExpression[],\n    /** ...starting from here. */\n    idx: number,\n    /**\n     * Expressions we've already precomputed\n     * in a previous run, used to reveal new paths\n     * and stop searching if there aren't any paths remaining.\n     */\n    learnedExpressions: Set<number>,\n    visitedExpressions: Set<number> = new Set(),\n): BitVector | undefined {\n    if (visitedExpressions.has(idx)) {\n        return undefined;\n    }\n    const expr = requirements[idx];\n    if (expr.isTriviallyFalse()) {\n        return undefined;\n    }\n\n    if (learnedExpressions.has(idx)) {\n        return undefined;\n    }\n\n    visitedExpressions.add(idx);\n\n    for (const conj of requirements[idx].conjunctions) {\n        for (const bit of conj.iter()) {\n            if (!opaqueBits.test(bit) && !learnedExpressions.has(bit)) {\n                const moreBits = findNewSubgoals(\n                    opaqueBits,\n                    requirements,\n                    bit,\n                    learnedExpressions,\n                    visitedExpressions,\n                );\n                if (moreBits) {\n                    return new BitVector()\n                        .setBit(bit)\n                        .or(moreBits);\n                }\n            }\n        }\n    }\n\n    visitedExpressions.delete(idx);\n    return new BitVector();\n}\n\n/**\n * Convert the expression at `idx` to a first-order logic expression\n * that is only based on the ground terms `opaqueBits` - in other words,\n * create a closed formula for the potentially (self- and nested-)recursive\n * expression at `idx`.\n */\nexport function computeGroundExpression(\n    opaqueBits: BitVector,\n    requirements: LogicalExpression[],\n    idx: number,\n    visitedExpressions: Set<number> = new Set(),\n): LogicalExpression {\n    let result = LogicalExpression.false();\n    if (visitedExpressions.has(idx)) {\n        return result;\n    }\n    visitedExpressions.add(idx);\n\n    // TODO this is a standard BRANCH algorithm but we don't have a BOUND.\n    // It'd be useful to know when we've found the minimum requirements and\n    // when exploring additional paths wouldn't help.\n\n    // TODO even with a BOUND this may not be the best solution. In practice this\n    // works for some requirements, is fairly slow for others, and fails catastrophically\n    // for a few unless some specific subgoals are evaluated first (see `findNewSubgoals`).\n    // So if you see the tooltips task getting stuck, it's likely here and because `findNewSubgoals`\n    // didn't make us learn an important expression.\n    // Some alternatives:\n    // * Not output a DNF but a multi-level form. This however needs tooltips to implement\n    //   more sophisticated simplification algorithms.\n    // * Convert the requirements to a proper directed graph structure first, where things like\n    //   degree and \"bottlenecks\" are known, then use better heuristics there.\n    // * Find a All-SAT solver that can deal with fixed-point logic.\n    //   Good luck with that, SAT solvers need input in CNF, All-SAT solvers seem to\n    //   only exist in theory, and cycles are not considered.\n\n    nextConj: for (const conj of requirements[idx].conjunctions) {\n        let tmpExpr = LogicalExpression.true();\n        const conjOpaqueBits = opaqueBits.and(conj);\n        for (const bit of conj.iter()) {\n            if (!conjOpaqueBits.test(bit)) {\n                const newTerm = computeGroundExpression(\n                    opaqueBits,\n                    requirements,\n                    bit,\n                    visitedExpressions,\n                );\n                if (newTerm.isTriviallyFalse()) {\n                    continue nextConj;\n                }\n                tmpExpr = tmpExpr.and(newTerm).removeDuplicates();\n            }\n        }\n        if (conjOpaqueBits.numSetBits) {\n            tmpExpr = tmpExpr.and(conjOpaqueBits);\n        }\n\n        result = result.or(tmpExpr);\n    }\n\n    visitedExpressions.delete(idx);\n    return result.removeDuplicates();\n}\n\nexport function removeDuplicates(logic: BitLogic) {\n    for (const [idx, expr] of logic.entries()) {\n        if (expr.conjunctions.length >= 2) {\n            logic[idx] = expr.removeDuplicates();\n        }\n    }\n}\n\n/**\n * Unifies non-opaque requirements if they directly imply each other. This is mostly\n * for simplifying clusters like the Sky, where there are lots of areas that are\n * all equally accessible as long as you're somewhere in the sky. This means one of\n * the unified areas will only have a single bit requirement, which can be inlined later.\n *\n * Returns true iff any simplifications have been made.\n */\nexport function unifyRequirements(\n    opaqueBits: BitVector,\n    requirements: LogicalExpression[],\n) {\n    // First, an O(n) scan to rule out expressions that are definitely not eligible\n    const unificationCandidates: number[][] = requirements.map(() => []);\n    for (const [idx, expr] of requirements.entries()) {\n        if (opaqueBits.test(idx)) {\n            continue;\n        }\n        for (const conj of expr.conjunctions) {\n            if (conj.numSetBits === 1) {\n                const bit = conj.getSingleSetBit();\n                if (bit === idx || opaqueBits.test(bit)) {\n                    continue;\n                }\n                (unificationCandidates[bit]).push(idx);\n            }\n        }\n    }\n\n    let simplified = false;\n    for (let a = 0; a < requirements.length; a++) {\n        const targetList = unificationCandidates[a];\n        for (const b of targetList) {\n            if (tryUnifyEquivalent(requirements, a, b)) {\n                simplified = true;\n            }\n        }\n    }\n\n    return simplified;\n}\n\n/**\n * Check if:\n *  z <= a\n *  a <= b | x\n *  b <= a | y\n * Rewrite to:\n *  z <= a\n *  a <= b,\n *  b <= x | y,\n * This breaks a cycle between `a` and `b`, and any dependencies on `a`\n * can be rewritten to depend on `b` in a later shallowSimplify call.\n */\nfunction tryUnifyEquivalent(requirements: LogicalExpression[], a: number, b: number) {\n    const implA = requirements[a];\n    const implB = requirements[b];\n\n    if (implA.conjunctions.length < 2 || implB.conjunctions.length < 2) {\n        return false;\n    }\n\n    const bImpliesAIndex = implA.conjunctions.findIndex(\n        (cA) => cA.numSetBits === 1 && cA.test(b),\n    );\n    if (bImpliesAIndex === -1) {\n        return false;\n    }\n\n    const aImpliesBIndex = implB.conjunctions.findIndex(\n        (cB) => cB.numSetBits === 1 && cB.test(a),\n    );\n    if (aImpliesBIndex === -1) {\n        return false;\n    }\n\n    // Copy reqs from a to b\n    const implACon = implA.conjunctions.slice();\n    const bReqVec = implACon.splice(bImpliesAIndex, 1);\n    for (const cn of implACon) {\n        requirements[b] = requirements[b].or(cn);\n    }\n    requirements[a] = new LogicalExpression(bReqVec);\n\n    return true;\n}\n\n/**\n * Shallow simplification \"inlines\" non-opaque requirements that themselves only consist\n * of at most one conjunction into upstream conjunctions. A DNF requirement with zero\n * conjunctions is always False, so any conjunctions it appears in can be dropped,\n * while a DNF with exactly one conjunction can be inlined.\n *\n * Returns true iff any simplifications could be made.\n * \n * \n * E.g:\n *   a <= b&c | f | d\n *   b <= <false>\n *   d <= e\n *   f <= g&h\n * Rewrite to:\n *   a <= g&h | e\n *   b <= <false>\n *   d <= e\n *   f <= g&h\n */\nexport function shallowSimplify(\n    opaqueBits: BitVector,\n    requirements: BitLogic,\n) {\n    const inliningCandidates = new BitVector();\n\n    let simplified = false;\n\n    for (let item = 0; item < requirements.length; item++) {\n        if (\n            !opaqueBits.test(item) &&\n            requirements[item].conjunctions.length <= 1\n        ) {\n            inliningCandidates.setBit(item);\n        }\n    }\n\n    for (const [idx, expr] of requirements.entries()) {\n        if (expr.conjunctions.length >= 30 || opaqueBits.test(idx)) {\n            continue;\n        }\n        let newExpr = LogicalExpression.false();\n        for (const conj of expr.conjunctions) {\n            if (conj.intersects(inliningCandidates)) {\n                simplified = true;\n                let newItems = new BitVector();\n                let skip = false;\n                for (const reqItem of conj.iter()) {\n                    if (!inliningCandidates.test(reqItem)) {\n                        newItems.setBit(reqItem);\n                    } else {\n                        const revealed = requirements[reqItem];\n\n                        if (revealed.isTriviallyTrue()) {\n                            continue;\n                        }\n\n                        if (revealed.isTriviallyFalse()) {\n                            skip = true;\n                            break;\n                        }\n                        newItems = newItems.or(revealed.conjunctions[0]);\n                    }\n                }\n                if (!skip && !newItems.test(idx)) {\n                    newExpr = newExpr.or(newItems);\n                }\n            } else {\n                newExpr = newExpr.or(conj);\n            }\n        }\n\n        requirements[idx] = newExpr;\n    }\n    return simplified;\n}\n","import _ from 'lodash';\n\nexport enum Op {\n    And = 'and',\n    Or = 'or',\n}\n\nexport type Item = BooleanExpression | string;\ntype BinOp<T> = (left: T, right: T) => boolean;\ntype ParentItems = {\n    [op in Op]: Item[]\n}\n\nexport type ReducerArg<T> = { isReduced: true, accumulator: T, item: T } | { isReduced: false, accumulator: T, item: string };\ntype Reducer<T> = (arg: ReducerArg<T>) => T;\ntype Reducers<T> = {\n    andInitialValue: T,\n    orInitialValue: T,\n    andReducer: Reducer<T>,\n    orReducer: Reducer<T>,\n}\n\nexport class BooleanExpression {\n    type: Op;\n    items: Item[];\n\n    constructor(items: Item[], type: Op) {\n        this.items = items;\n        this.type = type;\n    }\n\n    static and(...items: Item[]) {\n        return new BooleanExpression(items, Op.And);\n    }\n\n    static or(...items: Item[]) {\n        return new BooleanExpression(items, Op.Or);\n    }\n\n    isAnd() {\n        return this.type === Op.And;\n    }\n\n    isOr() {\n        return this.type === Op.Or;\n    }\n\n    reduce<T>({\n        andInitialValue,\n        andReducer,\n        orInitialValue,\n        orReducer,\n    }: Reducers<T>): T {\n        const reducerArguments = (accumulator: T, item: Item): ReducerArg<T> => {\n            if (BooleanExpression.isExpression(item)) {\n                const reducedItem = item.reduce({\n                    andInitialValue,\n                    andReducer,\n                    orInitialValue,\n                    orReducer,\n                });\n\n                return {\n                    accumulator,\n                    item: reducedItem,\n                    isReduced: true,\n                };\n            }\n            return {\n                accumulator,\n                item,\n                isReduced: false,\n            };\n        };\n\n        if (this.isAnd()) {\n            return _.reduce(\n                this.items,\n                (acc, item) => andReducer(\n                    reducerArguments(acc, item),\n                ),\n                andInitialValue,\n            );\n        }\n\n        if (this.isOr()) {\n            return _.reduce(\n                this.items,\n                (acc, item) => orReducer(\n                    reducerArguments(acc, item),\n                ),\n                orInitialValue,\n            );\n        }\n        throw Error(`Invalid type: ${this.type}`);\n    }\n\n    evaluate(isItemTrue: (item: string) => boolean) {\n        return this.reduce({\n            andInitialValue: true,\n            andReducer: ({ accumulator, item, isReduced }) => accumulator && (isReduced ? item : isItemTrue(item)),\n            orInitialValue: false,\n            orReducer: ({ accumulator, item, isReduced }) => accumulator || (isReduced ? item : isItemTrue(item)),\n        });\n    }\n\n    simplify(implies: BinOp<string>, iterations = 3) {\n        let updatedExpression = this.flatten();\n\n        for (let i = 0; i < iterations; i++) {\n            updatedExpression = updatedExpression.removeDuplicateChildren(implies);\n            updatedExpression = updatedExpression.removeDuplicateExpressions(implies);\n            updatedExpression = updatedExpression.shiftWeakerTermsUp(implies);\n        }\n\n        return updatedExpression;\n    }\n\n    oppositeType() {\n        if (this.isAnd()) {\n            return Op.Or;\n        }\n        if (this.isOr()) {\n            return Op.And;\n        }\n        throw Error(`Invalid type for boolean expression: ${this.type}`);\n    }\n\n    static isExpression(item: unknown): item is BooleanExpression {\n        return typeof item === 'object' && item instanceof BooleanExpression;\n    }\n\n    isEqualTo(otherExpression: Item, areItemsEqual: BinOp<string>): boolean {\n        if (!BooleanExpression.isExpression(otherExpression) || this.type !== otherExpression.type || this.items.length !== otherExpression.items.length) {\n            return false;\n        }\n\n        const difference = _.xorWith(this.items, otherExpression.items, (item, otherItem) => {\n            if (BooleanExpression.isExpression(item)) {\n                return item.isEqualTo(otherItem, areItemsEqual);\n            }\n            // if one item is not an expression and the other is not then they cannot be equal\n            if (BooleanExpression.isExpression(otherItem)) {\n                return false;\n            }\n            return areItemsEqual(item, otherItem);\n        });\n        return _.isEmpty(difference);\n    }\n\n    flatten(): BooleanExpression {\n        const newItems = this.items.flatMap((item) => {\n            if (!BooleanExpression.isExpression(item)) {\n                return item;\n            }\n            const flatItem = item.flatten();\n            if (_.isEmpty(flatItem.items)) {\n                return [];\n            }\n            if (flatItem.type === this.type || flatItem.items.length === 1) {\n                return flatItem.items;\n            }\n            return flatItem;\n        });\n\n        if (newItems.length === 1) {\n            const firstItem = _.first(newItems);\n            if (BooleanExpression.isExpression(firstItem)) {\n                return firstItem;\n            }\n        }\n\n        return new BooleanExpression(newItems, this.type);\n    }\n\n    static createFlatExpression(items: Item[], type: Op) {\n        return new BooleanExpression(items, type).flatten();\n    }\n\n    // determines if a provided item is subsumed by a provided collection of items\n    // calculation depends on the type of the containing expression\n    // implies is the function for determing if requirements are subsumable (defines the relationship between items)\n    static itemIsSubsumed(itemsCollection: Item[], item: string, expressionType: Op, implies: BinOp<string>) {\n        let itemIsSubsumed = false;\n        itemsCollection.forEach((otherItem) => {\n            if (this.isExpression(otherItem)) {\n                return true;\n            }\n\n            switch (expressionType) {\n                case Op.And: {\n                    // for and logic the subsuming item (the item from the collection) needs to imply the subsumed item\n                    // otherwise the logic would lose precision on counted items (i.e. Sword x2 could subsume Sword x3 depending on sequence)\n                    if (implies(otherItem, item)) {\n                        itemIsSubsumed = true;\n                        return false;\n                    }\n                    break;\n                }\n                case Op.Or: {\n                    // for an or expression this precision doesn't matter - Sword x2 is just as good as Sword x3, therefore any implying\n                    // item can subsume the item in question\n                    if (implies(item, otherItem)) {\n                        itemIsSubsumed = true;\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        });\n        return itemIsSubsumed;\n    }\n\n    getUpdatedParentItems(parentItems: ParentItems) {\n        return _.mergeWith({}, parentItems, { [this.type]: this.items }, (objectValue: Item[], sourceValue: Item[]) => {\n            if (_.isArray(objectValue)) {\n                return _.concat(objectValue, _.filter(sourceValue, (value) => !BooleanExpression.isExpression(value)));\n            }\n            return undefined;\n        });\n    }\n\n    removeDuplicateChildrenHelper(implies: BinOp<string>, parentItems: ParentItems) {\n        const newItems: Item[] = [];\n        const updatedParentItems = this.getUpdatedParentItems(parentItems);\n        const sameTypeItems = _.get(parentItems, this.type);\n        const oppositeTypeItems = _.get(parentItems, this.oppositeType());\n        let removeSelf = false;\n\n        this.items.forEach((item) => {\n            if (BooleanExpression.isExpression(item)) {\n                const {\n                    expression: childExpression,\n                    removeParent: childRemoveParent,\n                } = item.removeDuplicateChildrenHelper(implies, updatedParentItems);\n\n                if (childRemoveParent) {\n                    removeSelf = true;\n                    return false;\n                }\n                newItems.push(childExpression);\n            } else {\n                if (BooleanExpression.itemIsSubsumed(oppositeTypeItems, item, this.oppositeType(), implies)) {\n                    removeSelf = true;\n                    return false;\n                }\n\n                if (!BooleanExpression.itemIsSubsumed(sameTypeItems, item, this.type, implies)) {\n                    newItems.push(item);\n                }\n            }\n            return true;\n        });\n\n        if (removeSelf) {\n            return {\n                expression: BooleanExpression.and(),\n                removeParent: false,\n            };\n        }\n\n        const expression = BooleanExpression.createFlatExpression(newItems, this.type);\n        if (_.isEmpty(expression.items)) {\n            return {\n                expression: BooleanExpression.and(),\n                removeParent: true,\n            };\n        }\n\n        return {\n            expression,\n            removeParent: false,\n        };\n    }\n\n    removeDuplicateChildren(implies: BinOp<string>) {\n        const { expression } = this.removeDuplicateChildrenHelper(implies, {\n            [Op.And]: [],\n            [Op.Or]: [],\n        });\n        return expression;\n    }\n\n    isSubsumedBy(otherExpression: BooleanExpression, implies: BinOp<string>, removeIfIdentical: boolean, expressionType: Op): boolean {\n        if (this.isEqualTo(otherExpression, (item, otherItem) => implies(item, otherItem) && implies(otherItem, item))) {\n            return removeIfIdentical;\n        }\n        return otherExpression.items.every((otherItem) => {\n            if (BooleanExpression.isExpression(otherItem)) {\n                return this.isSubsumedBy(otherItem, implies, true, expressionType);\n            }\n            return BooleanExpression.itemIsSubsumed(this.items, otherItem, expressionType, implies);\n        });\n    }\n\n    expressionIsSubsumed(expression: BooleanExpression, index: number, implies: BinOp<string>) {\n        let expressionIsSubsumed = false;\n        this.items.forEach((otherItem, otherIndex) => {\n            if (otherIndex === index) {\n                return true;\n            }\n\n            let otherExpression: BooleanExpression;\n            if (BooleanExpression.isExpression(otherItem)) {\n                otherExpression = otherItem;\n            } else {\n                otherExpression = BooleanExpression.and(otherItem);\n            }\n\n            const isSubsumed = expression.isSubsumedBy(otherExpression, implies, otherIndex < index, this.oppositeType());\n            if (isSubsumed) {\n                expressionIsSubsumed = true;\n                return false;\n            }\n            return true;\n        });\n        return expressionIsSubsumed;\n    }\n\n    removeDuplicateExpressionsInChildren(implies: BinOp<string>): BooleanExpression {\n        const newItems = this.items.map((item) => {\n            if (BooleanExpression.isExpression(item)) {\n                return item.removeDuplicateExpressions(implies);\n            }\n            return item;\n        });\n        return BooleanExpression.createFlatExpression(newItems, this.type);\n    }\n\n    removeDuplicateExpressions(implies: BinOp<string>): BooleanExpression {\n        const parentExpression = this.removeDuplicateExpressionsInChildren(implies);\n        const newItems = parentExpression.items.filter((item, index) => {\n            let expression;\n            if (BooleanExpression.isExpression(item)) {\n                expression = item;\n            } else {\n                expression = BooleanExpression.and(item);\n            }\n\n            return !parentExpression.expressionIsSubsumed(expression, index, implies);\n        });\n\n        if (this.type === Op.Or && newItems.length >= 2 && _.every(_.map(newItems, BooleanExpression.isExpression))) {\n            const commonFactors: Item[] = [];\n            const booleanItems = newItems as BooleanExpression[];\n            _.forEach(booleanItems[0].items, (item) => {\n                if (_.every(_.map(booleanItems, (expr) => _.includes(expr.items, item)))) {\n                    commonFactors.push(item);\n                }\n            });\n            if (commonFactors.length) {\n                return new BooleanExpression([...commonFactors, new BooleanExpression([...(newItems.filter((item) => !commonFactors.includes(item)))], this.type)], this.oppositeType());\n            }\n        }\n        return BooleanExpression.createFlatExpression(newItems, this.type);\n    }\n\n    shiftWeakerTermsUp(implies: BinOp<string>): BooleanExpression {\n        const parentExpression = this.removeDuplicateExpressionsInChildren(implies);\n        if (parentExpression.isOr() && parentExpression.items.every((i) => !BooleanExpression.isExpression(i) || i.isAnd())) {\n            for (const item of parentExpression.items) {\n                if (!BooleanExpression.isExpression(item)) {\n                    continue;\n                }\n                for (const subItem of item.items) {\n                    if (BooleanExpression.isExpression(subItem) && parentExpression.items.every((otherItem, index) => (otherItem as BooleanExpression).expressionIsSubsumed(subItem, index, implies))) {\n                        console.log('blub')\n                        return BooleanExpression.and(subItem, BooleanExpression.or(...parentExpression.items, ));\n                    }\n                }\n            }\n        }\n\n        return parentExpression;\n    }\n}\n\nexport default BooleanExpression;\n","import _ from 'lodash';\nimport {\n    computeGroundExpression,\n    findNewSubgoals,\n    removeDuplicates,\n    shallowSimplify,\n    unifyRequirements,\n} from '../../logic/bitlogic/BitLogic';\nimport { BitVector } from '../../logic/bitlogic/BitVector';\nimport { LogicalExpression } from '../../logic/bitlogic/LogicalExpression';\nimport {\n    deserializeLogicalExpression,\n    serializeBooleanExpression,\n} from './Utils';\nimport { LeanLogic, WorkerRequest, WorkerResponse } from './Types';\nimport BooleanExpression, {\n    Item,\n} from '../../logic/booleanlogic/BooleanExpression';\n\n/**\n * This module contains various strategies to turn the requirements into a more compact and readable\n * form, with the goal of creating readable and understandable requirements for tooltips.\n */\n\n/**\n * Global application state. Will be initialized with the first message.\n */\ninterface GlobalState {\n    logic: LeanLogic;\n    opaqueBits: BitVector;\n    learned: Set<number>;\n    requirements: LogicalExpression[];\n}\n\nlet g: GlobalState;\n\nconsole.log('Hello from worker!');\n\nonmessage = (ev: MessageEvent<WorkerRequest>) => {\n    const start = performance.now();\n    switch (ev.data.type) {\n        case 'initialize': {\n            const opaqueBits = new BitVector();\n            for (const bit of ev.data.opaqueBits) {\n                opaqueBits.setBit(bit);\n            }\n            g = {\n                logic: ev.data.logic,\n                opaqueBits,\n                learned: new Set(),\n                requirements: ev.data.requirements.map(\n                    deserializeLogicalExpression,\n                ),\n            };\n\n            do {\n                // First, perform some cheap optimizations that will help every\n                // query afterwards.\n                removeDuplicates(g.requirements);\n                while (shallowSimplify(g.opaqueBits, g.requirements)) {\n                    removeDuplicates(g.requirements);\n                }\n            } while (unifyRequirements(g.opaqueBits, g.requirements));\n            console.log('worker', 'initializing and pre-simplifying took', performance.now() - start, 'ms');\n            break;\n        }\n        case 'analyze': {\n            if (!g) {\n                throw new Error('needs to be initialized first!!!!');\n            }\n            const expr = analyze(ev.data.checkId);\n            console.log('worker', 'total time for', ev.data.checkId, 'was', performance.now() - start, 'ms');\n            postMessage({\n                checkId: ev.data.checkId,\n                expression: serializeBooleanExpression(expr),\n            } satisfies WorkerResponse);\n        }\n    }\n};\n\nfunction analyze(checkId: string): BooleanExpression {\n    const bit = g.logic.itemBits[checkId];\n\n    // We precompute (\"learn\") some subgoals because it improves performance.\n    // However, we can sometimes end up precomputing trivial requirements\n    // like \\Distance Activator for X Rupee items while expensive requirements\n    // like \\Can Medium Rupee Farm end up being not \"learned\" yet. So\n    // we always perform a minimum amount of work per item.\n    let numLearnedInPrecomputation = 0;\n    while (numLearnedInPrecomputation < 5) {\n        const potentialPath = findNewSubgoals(\n            g.opaqueBits,\n            g.requirements,\n            bit,\n            g.learned,\n        );\n\n        if (potentialPath && !potentialPath.isEmpty()) {\n            for (const precomputeBit of potentialPath.iter()) {\n                if (\n                    !g.opaqueBits.test(precomputeBit) &&\n                    !g.learned.has(precomputeBit)\n                ) {\n                    // And then precompute some non-opaque requirements. This persists between tooltips, so\n                    // different checks can reuse these results.\n                    // Note that even though the result of `findNewSubgoals` is obviously path-dependent and depends on the check in question,\n                    // this particular call happens in isolation and has no dependencies on the check in question, so reusing is sound!\n                    const start = performance.now();\n                    g.requirements[precomputeBit] = computeGroundExpression(\n                        g.opaqueBits,\n                        g.requirements,\n                        precomputeBit,\n                    );\n                    console.log('  ', 'worker', 'precomputing', g.logic.allItems[precomputeBit], 'took', performance.now() - start, 'ms');\n                    g.learned.add(precomputeBit);\n                    numLearnedInPrecomputation += 1;\n                }\n            }\n        } else {\n            // There are no subgoals to learn, so we can go straight to computing the goal.\n            break;\n        }\n    }\n\n    const start = performance.now();\n    const opaqueOnlyExpr = computeGroundExpression(\n        g.opaqueBits,\n        g.requirements,\n        bit,\n    );\n    console.log('  ', 'worker', 'computing', g.logic.allItems[bit], 'took', performance.now() - start, 'ms');\n    g.requirements[bit] = opaqueOnlyExpr;\n\n    const simplifyStart = performance.now();\n    const simplified = dnfToRequirementExpr(g.logic, opaqueOnlyExpr.conjunctions);\n    console.log('  ', 'worker', 'simplifying took', performance.now() - simplifyStart, 'ms');\n    return simplified;\n}\n\nfunction simplifier(logic: LeanLogic) {\n    return (a: string, b: string) => {\n        return a === b || Boolean(logic.dominators[b]?.includes(a));\n    };\n}\n\n/**\n * Converts a DNF to a readable requirements expression.\n *\n * Our DNF is a sum of products (SOP) with no negations and no don't-cares.\n * As a result, standard two-level simplification algorithms (Quine-McCluskey/Karnaugh Maps)\n * will not produce any simplifications.\n *\n * Instead, we are doing multi-level simplification as described in:\n * https://faculty.sist.shanghaitech.edu.cn/faculty/zhoupq/Teaching/Spr16/07-Multi-Level-Logic-Synthesis.pdf\n * https://www2.eecs.berkeley.edu/Pubs/TechRpts/1989/ERL-89-49.pdf (pp. 41-70)\n * We first remove all factors, and then treat the rest SOP as an algebraic expression.\n * Algebraic expressions don't know about special boolean rules (like a && !a = 0, a || !a = 1)\n * but since we don't have any don't cares and negations they will never be relevant.\n */\nexport function dnfToRequirementExpr(\n    logic: LeanLogic,\n    sop: BitVector[],\n): BooleanExpression {\n    if (sop.length === 0) {\n        return BooleanExpression.or();\n    }\n\n    if (sop.length === 1 && sop[0].isEmpty()) {\n        return BooleanExpression.and();\n    }\n\n    /*\n    return BooleanExpression.or(\n        ...sop.map((s) =>\n            BooleanExpression.and(\n                ...[...s.iter()].map((bit) => logic.allItems[bit]),\n            ),\n        ),\n    );\n    */\n\n    if (sop.length === 1) {\n        return BooleanExpression.and(\n            ...[...sop[0].iter()].map((x) => logic.allItems[x]),\n        ).simplify(simplifier(logic));\n    }\n\n    const conjunctions = new LogicalExpression(sop).removeDuplicates()\n        .conjunctions;\n\n    // After removing duplicates, remove dominated stuff from our terms so that\n    // simplification doesn't get funny ideas like pulling out irrelevant terms\n    // that we later can't easily simplify in a multi level form.\n    for (const conj of conjunctions) {\n        for (const bit of [...conj.iter()]) {\n            for (const dominator of logic.dominators[logic.allItems[bit]] ?? []) {\n                const dominatorBit = logic.itemBits[dominator];\n                if (dominatorBit !== bit && conj.test(dominatorBit)) {\n                    conj.clearBit(bit);\n                }\n            }\n        }\n    }\n\n    // First, remove all common factors and from our SOP so that it's \"cube-free\".\n    // This is a requirement for the algorithm to work, as per the presentation.\n    let commonFactors = new Set<number>(conjunctions[0].iter());\n    for (const conj of conjunctions) {\n        commonFactors = new Set(\n            // eslint-disable-next-line no-loop-func\n            [...conj.iter()].filter((b) => commonFactors.has(b)),\n        );\n    }\n\n    // Build a list of all variables mentioned in this expression.\n    const variables = new Set<number>();\n\n    for (const conj of conjunctions) {\n        for (const bit of commonFactors) {\n            conj.clearBit(bit);\n        }\n        for (const bit of conj.iter()) {\n            variables.add(bit);\n        }\n    }\n\n    // At this point it's best to just consult the lecture presentation for why this is happening.\n    const kernels = findKernels(\n        conjunctions,\n        [...variables],\n        new BitVector(),\n    ).filter((k) => !k.coKernel.isEmpty());\n\n    // Columns are all unique cubes in all kernels\n    const columns = kernels.reduce<BitVector[]>((acc, kernel) => {\n        for (const kCube of kernel.kernel) {\n            if (!acc.some((cube) => kCube.equals(cube))) {\n                acc.push(kCube);\n            }\n        }\n        return acc;\n    }, []);\n\n    // Rows are labelled with all unique co-kernels.\n    const rows = kernels;\n\n    if (rows.length > 0 && columns.length > 0) {\n        // Create a matrix with ones in places where column cube appears in row kernel.\n        const matrix = Array<(0 | 1)[]>(rows.length)\n            .fill([])\n            .map(() => Array<0 | 1>(columns.length).fill(0));\n        for (const [col, kernelCube] of columns.entries()) {\n            for (const [row, coKernel] of rows.entries()) {\n                if (coKernel.kernel.some((kCube) => kCube.equals(kernelCube))) {\n                    matrix[row][col] = 1;\n                }\n            }\n        }\n\n        // Again look at the lecture presentation here.\n        const rowWeight = (row: number) => rows[row].coKernel.numSetBits + 1;\n        const colWeight = (col: number) => columns[col].numSetBits;\n        const value = (col: number, row: number) =>\n            rows[row].coKernel.or(columns[col]).numSetBits;\n\n        const literalsSaved = (rectRows: number[], rectCols: number[]) =>\n            _.sumBy(rectRows, (row) =>\n                _.sumBy(rectCols, (col) =>\n                    matrix[row][col] ? value(col, row) : 0,\n                ),\n            ) -\n            _.sumBy(rectRows, rowWeight) -\n            _.sumBy(rectCols, colWeight);\n\n        // This is the thesis algorithm for enumerating all prime rectangles.\n        // Theoretically the algorithm is branch-and-bound, but our problems\n        // are small enough for branch to be enough.\n        const allRects: [number[], number[]][] = [];\n        genRectangles(\n            rows.map((_val, idx) => idx),\n            columns.map((_val, idx) => idx),\n            matrix,\n            (rows, cols) => {\n                allRects.push([rows, cols]);\n                // No bound.\n                return true;\n            },\n        );\n\n        if (allRects.length) {\n            const [, rectCols] = _.maxBy(allRects, ([rows, cols]) =>\n                literalsSaved(rows, cols),\n            )!;\n\n            const divisor = rectCols.map((col) => columns[col]);\n            // console.log('would extract:', divisor.map((val) => [...val.iter()].map((bit) => logic.allItems[bit]).join('&')).join(' + '));\n            // console.log('original expression:', conjunctions.map((val) => [...val.iter()].map((bit) => logic.allItems[bit]).join('&')).join(' + '));\n            // const divTimer = performance.now();\n            const { quotient, remainder } = algebraicDivision(\n                conjunctions,\n                divisor,\n            );\n            // console.log(`algebraic division took`, performance.now() - divTimer, 'ms');\n\n            // Recursively simplify the quotient, divisor and remainder (divisor probably doesn't need to be...)\n\n            const optQuotient = new LogicalExpression(\n                quotient,\n            ).removeDuplicates();\n            const andTerms: Item[] = [...commonFactors].map(\n                (f) => logic.allItems[f],\n            );\n            const product = BooleanExpression.and(\n                dnfToRequirementExpr(logic, optQuotient.conjunctions),\n                dnfToRequirementExpr(logic, divisor),\n            );\n            const sum = BooleanExpression.or(\n                product,\n                dnfToRequirementExpr(logic, remainder),\n            );\n\n            // CommonFactor1 and CommonFactor2 and (Quotient and Divisor or Remainder)\n            return BooleanExpression.and(...andTerms, sum).simplify(\n                simplifier(logic),\n            );\n        }\n    }\n\n    // CommonFactor1 and CommonFactor2 and (SOPWithoutCommonFactors)\n    return BooleanExpression.and(\n        ...[...commonFactors].map((i) => logic.allItems[i]),\n        BooleanExpression.or(\n            ...conjunctions.map((c) => bitVecToRequirements(logic, c)),\n        ),\n    ).simplify(simplifier(logic));\n}\n\nfunction genRectangles(\n    allRows: number[],\n    allCols: number[],\n    matrix: (0 | 1)[][],\n    callback: (rows: number[], cols: number[]) => boolean,\n) {\n    // Trivial rectangles are rectangles of height 1 or width 1.\n    // A trivial row rectangle is *prime* if no other row\n    // has ones everywhere we have ones. Expressed differently:\n    // We're prime if there is no such other row that for every column,\n    // \"our row has a 1\" implies \"other row has a 1\" (and by A=>B <=> Bv!A)\n    for (const row of allRows) {\n        const ones = allCols.filter((col) => matrix[row][col]);\n        if (\n            ones.length &&\n            !allRows.some(\n                (otherRow) =>\n                    otherRow !== row &&\n                    allCols.every(\n                        (otherCol) =>\n                            !ones.includes(otherCol) ||\n                            matrix[otherRow][otherCol],\n                    ),\n            )\n        ) {\n            callback([row], ones);\n        }\n    }\n\n    for (const col of allCols) {\n        const ones = allRows.filter((row) => matrix[row][col]);\n        if (\n            ones.length &&\n            !allCols.some(\n                (otherCol) =>\n                    otherCol !== col &&\n                    allRows.every(\n                        (otherRow) =>\n                            !ones.includes(otherRow) ||\n                            matrix[otherRow][otherCol],\n                    ),\n            )\n        ) {\n            callback(ones, [col]);\n        }\n    }\n    genRectanglesRecursive(allRows, allCols, matrix, 0, [], [], callback);\n}\n\nfunction genRectanglesRecursive(\n    allRows: number[],\n    allCols: number[],\n    matrix: (0 | 1)[][],\n    index: number,\n    // The paper doesn't use this?\n    _rectRows: number[],\n    rectCols: number[],\n    callback: (rows: number[], cols: number[]) => boolean,\n) {\n    for (const c of allCols) {\n        if (c >= index && allRows.filter((row) => matrix[row][c]).length >= 2) {\n            // create M1 with rows 0 where c is 0 and rows intact where c is 1\n            const m1 = matrix.map((row, rowIndex) =>\n                matrix[rowIndex][c] ? row.slice() : row.map(() => 0 as const),\n            );\n            const rect1Rows = allRows.filter((row) => matrix[row][c]);\n            const rect1Cols = rectCols.slice();\n\n            let prune = false;\n            for (const c1 of allCols) {\n                if (\n                    allRows.filter((row) => m1[row][c1]).length ===\n                    allRows.filter((row) => matrix[row][c]).length\n                ) {\n                    if (c1 < c) {\n                        prune = true;\n                        break;\n                    } else {\n                        rect1Cols.push(c1);\n                        for (const row of allRows) {\n                            m1[row][c1] = 0;\n                        }\n                    }\n                }\n            }\n\n            if (!prune) {\n                const bound = callback(rect1Rows, rect1Cols);\n                if (!bound) {\n                    genRectanglesRecursive(\n                        allRows,\n                        allCols,\n                        m1,\n                        c,\n                        rect1Rows,\n                        rect1Cols,\n                        callback,\n                    );\n                }\n            }\n        }\n    }\n}\n\nfunction findKernels(\n    cubes: BitVector[],\n    variables: number[],\n    coKernelPath: BitVector,\n    seenCoKernels: BitVector[] = [],\n    minIdx = 0,\n): { kernel: BitVector[]; coKernel: BitVector }[] {\n    const kernels = [];\n    for (const [idx, bit] of variables.entries()) {\n        if (idx < minIdx) {\n            continue;\n        }\n        const s = cubes.filter((c) => c.test(bit));\n        if (s.length >= 2) {\n            const co = s.reduce((acc, c) => acc.and(c), s[0]);\n            const subPath = coKernelPath.or(co);\n            const quot = algebraicDivision(cubes, [co]).quotient;\n            const subKernels = findKernels(\n                quot,\n                variables,\n                subPath,\n                seenCoKernels,\n                idx + 1,\n            );\n            for (const sub of subKernels) {\n                if (\n                    !seenCoKernels.some((seenCo) => seenCo.equals(sub.coKernel))\n                ) {\n                    seenCoKernels.push(sub.coKernel);\n                    kernels.push(sub);\n                }\n            }\n        }\n    }\n\n    if (!seenCoKernels.some((seenCo) => seenCo.equals(coKernelPath))) {\n        kernels.push({\n            kernel: cubes,\n            coKernel: coKernelPath.clone(),\n        });\n    }\n\n    return kernels;\n}\n\nfunction algebraicDivision(\n    expr: BitVector[],\n    divisor: BitVector[],\n): { quotient: BitVector[]; remainder: BitVector[] } {\n    let quotient: BitVector[] | undefined;\n    for (const divCube of divisor) {\n        const c = expr\n            .filter((c) => divCube.isSubsetOf(c))\n            .map((c) => c.clone());\n        if (c.length === 0) {\n            return { quotient: [], remainder: expr };\n        }\n        for (const ci of c) {\n            for (const bit of divCube.iter()) {\n                ci.clearBit(bit);\n            }\n        }\n        if (!quotient) {\n            quotient = c;\n        } else {\n            quotient = quotient.filter((qc) => c.some((cc) => cc.equals(qc)));\n        }\n    }\n\n    const qd = new LogicalExpression(quotient!)\n        .and(new LogicalExpression(divisor))\n        .removeDuplicates();\n    const remainder = expr.filter(\n        (e) => !qd.conjunctions.some((qd) => qd.isSubsetOf(e)),\n    );\n    return { quotient: quotient!, remainder };\n}\n\nfunction bitVecToRequirements(\n    logic: LeanLogic,\n    vec: BitVector,\n): BooleanExpression {\n    return BooleanExpression.and(\n        ...[...vec.iter()].map((x) => logic.allItems[x]),\n    );\n}\n","import { BitVector } from '../../logic/bitlogic/BitVector';\nimport { LogicalExpression } from '../../logic/bitlogic/LogicalExpression';\nimport BooleanExpression, {\n    Item,\n    Op,\n} from '../../logic/booleanlogic/BooleanExpression';\nimport { SerializedBooleanExpression, SerializedItem } from './Types';\n\nexport function deserializeLogicalExpression(\n    expr: number[][],\n): LogicalExpression {\n    const terms = [];\n    for (const conj of expr) {\n        const vec = new BitVector();\n        for (const bit of conj) {\n            vec.setBit(bit);\n        }\n        terms.push(vec);\n    }\n    return new LogicalExpression(terms);\n}\n\nexport function serializeLogicalExpression(\n    expr: LogicalExpression,\n): number[][] {\n    return expr.conjunctions.map((c) => [...c.iter()]);\n}\n\nexport function serializeBooleanExpression(\n    expr: BooleanExpression,\n): SerializedBooleanExpression {\n    return serializeBooleanItem(expr) as SerializedBooleanExpression;\n}\n\nfunction serializeBooleanItem(item: Item): SerializedItem {\n    if (BooleanExpression.isExpression(item)) {\n        switch (item.type) {\n            case Op.And:\n                return {\n                    type: 'and',\n                    items: item.items.map(serializeBooleanItem),\n                };\n            case Op.Or:\n                return {\n                    type: 'or',\n                    items: item.items.map(serializeBooleanItem),\n                };\n        }\n    } else {\n        return item;\n    }\n}\n\nexport function deserializeBooleanExpression(\n    expr: SerializedBooleanExpression,\n): BooleanExpression {\n    return new BooleanExpression(\n        expr.items.map((i) =>\n            typeof i === 'string' ? i : deserializeBooleanExpression(i),\n        ),\n        expr.type === 'and' ? Op.And : Op.Or,\n    );\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [361], function() { return __webpack_require__(5221); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"2b022c30\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/gtrack/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t221: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunksshd_randomizer_tracker\"] = self[\"webpackChunksshd_randomizer_tracker\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(361).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["ONE","BigInt","ZERO","BitVector","bits","intSet","data","this","Set","bit","add","has","delete","other","a","b","size","tmp","filter","v","intersection","numSetBits","domainSize","str","Boolean","values","next","value","LogicalExpression","conjs","conjunctions","andToDnf2","isTriviallyFalse","false","drop","unless","map","c","test","clone","clearBit","terms","candidate","i","findIndex","t","isSubsetOf","strongerTerm","push","length","vec","some","isEmpty","left","right","newExpr","l","r","or","findNewSubgoals","opaqueBits","requirements","idx","learnedExpressions","visitedExpressions","expr","conj","iter","moreBits","setBit","computeGroundExpression","result","nextConj","tmpExpr","conjOpaqueBits","and","newTerm","removeDuplicates","logic","entries","unifyRequirements","unificationCandidates","getSingleSetBit","simplified","targetList","tryUnifyEquivalent","implA","implB","bImpliesAIndex","cA","cB","implACon","slice","bReqVec","splice","cn","shallowSimplify","inliningCandidates","item","intersects","newItems","skip","reqItem","revealed","isTriviallyTrue","Op","g","BooleanExpression","items","type","And","Or","andInitialValue","andReducer","orInitialValue","orReducer","reducerArguments","accumulator","isExpression","reduce","isReduced","isAnd","_","acc","isOr","Error","isItemTrue","implies","iterations","updatedExpression","flatten","removeDuplicateChildren","removeDuplicateExpressions","shiftWeakerTermsUp","otherExpression","areItemsEqual","difference","otherItem","isEqualTo","flatMap","flatItem","firstItem","parentItems","objectValue","sourceValue","updatedParentItems","getUpdatedParentItems","sameTypeItems","oppositeTypeItems","oppositeType","removeSelf","forEach","removeDuplicateChildrenHelper","childExpression","expression","removeParent","itemIsSubsumed","createFlatExpression","removeIfIdentical","expressionType","every","isSubsumedBy","index","expressionIsSubsumed","otherIndex","parentExpression","removeDuplicateExpressionsInChildren","commonFactors","booleanItems","includes","subItem","console","log","itemsCollection","deserializeLogicalExpression","serializeBooleanExpression","serializeBooleanItem","simplifier","dominators","dnfToRequirementExpr","sop","x","allItems","simplify","dominator","dominatorBit","itemBits","variables","kernels","findKernels","k","coKernel","columns","kernel","kCube","cube","equals","rows","matrix","Array","fill","col","kernelCube","row","rowWeight","colWeight","literalsSaved","rectRows","rectCols","allRects","allRows","allCols","callback","ones","otherRow","otherCol","genRectanglesRecursive","genRectangles","_val","cols","divisor","algebraicDivision","quotient","remainder","optQuotient","andTerms","f","product","sum","bitVecToRequirements","_rectRows","m1","rowIndex","rect1Rows","rect1Cols","prune","c1","cubes","coKernelPath","seenCoKernels","minIdx","s","co","subPath","subKernels","sub","seenCo","divCube","ci","qc","cc","qd","e","onmessage","ev","start","performance","now","learned","checkId","numLearnedInPrecomputation","potentialPath","precomputeBit","opaqueOnlyExpr","simplifyStart","analyze","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","id","loaded","__webpack_modules__","call","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","Object","keys","key","n","getter","__esModule","d","definition","o","defineProperty","enumerable","get","chunkId","Promise","all","promises","u","miniCssF","globalThis","Function","window","obj","prop","prototype","hasOwnProperty","nmd","paths","children","p","installedChunks","importScripts","chunkLoadingGlobal","self","parentChunkLoadingFunction","bind","moreModules","runtime","pop","then"],"sourceRoot":""}